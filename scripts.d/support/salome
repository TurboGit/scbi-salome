#! /usr/bin/env python3

################################################################
# WARNING: this file is automatically generated by SalomeTools #
# WARNING: and so could be overwritten at any time.            #
################################################################

import os
import sys
import subprocess
import os.path
from pathlib import Path
import glob
import re

os.environ["SALOME_MODULES"] = ""

# Add the pwdPath to able to run the launcher after unpacking a package
# Used only in case of a salomeTools package
out_dir_Path = Path( os.path.realpath(__file__) ).parent.absolute()
main_site_packages_tmp = out_dir_Path.parent.parent.parent / "lib"

pythonDirInLibCandidate = [ os.path.basename(elt) for elt in glob.glob( f"{main_site_packages_tmp}/python*" ) ]
if len(pythonDirInLibCandidate) != 1:
  raise RuntimeError( f"Fail to locate python* in {main_site_packages_tmp}" )
pythonDir = pythonDirInLibCandidate[0]

pat = re.compile("^python([\d])\.([\d]+)$")
if not pat.match(pythonDir):
  raise RuntimeError( f"Fail to locate pythonX.Y in {main_site_packages_tmp}" )
main_site_packages = main_site_packages_tmp / pythonDir / "site-packages"

# Preliminary work to initialize path to SALOME Python modules
def __initialize():

  # relative to __file__ supposed to be located on bin/salome/appli/salome
  sys.path[:0] = [
    f"{main_site_packages}",
    f"{out_dir_Path}" # parent directory of the current directory
  ]
  # define folder to store omniorb config (initially in virtual application folder)
  try:
    from salome.kernel.salomeContextUtils import setOmniOrbUserPath
    setOmniOrbUserPath()
  except Exception as e:
    print(e)
    sys.exit(1)
# End of preliminary work

# salome doc only works for virtual applications. Therefore we overwrite it with this function
def _showDoc(modules):
    for module in modules:
      modulePath = os.getenv(module+"_ROOT_DIR")
      if modulePath != None:
        baseDir = os.path.join(modulePath, "share", "doc", "salome")
        docfile = os.path.join(baseDir, "gui", module.upper(), "index.html")
        if not os.path.isfile(docfile):
          docfile = os.path.join(baseDir, "tui", module.upper(), "index.html")
        if not os.path.isfile(docfile):
          docfile = os.path.join(baseDir, "dev", module.upper(), "index.html")
        if os.path.isfile(docfile):
          out, err = subprocess.Popen(["xdg-open", docfile]).communicate()
        else:
          print("Online documentation is not accessible for module:", module)
      else:
        print(module+"_ROOT_DIR not found!")

def main(args):
  # Identify application path then locate configuration files
  __initialize()

  # Modify this variable to not reset the PATHS"
  reinitialise_paths=True

  if args == ['--help']:
    from salome.kernel.salomeContext_impl import usage
    usage()
    sys.exit(0)

  if '--keep-paths' in args:
    reinitialise_paths=False
    args.remove('--keep-paths')

  # Create a SalomeContext which parses configFileNames to initialize environment
  try:
    from salome.kernel.salomeContext_impl import SalomeContext, SalomeContextException
    if 'appendVariable' not in dir(SalomeContext):
      # check whether the appendVariable method is implemented
      def appendVariable(self, name, value, separator=os.pathsep):
        if value == '':
          return
        value = os.path.expandvars(value) # expand environment variables
        env = os.getenv(name, None)
        if env is None:
          os.environ[name] = value
        else:
          os.environ[name] = env + separator + value
        return
      SalomeContext.appendVariable = appendVariable

    context = SalomeContext(None)

    # Logger level error
    context.getLogger().setLevel(40)

    if reinitialise_paths:
      context.setVariable(r"PYTHONPATH", "", overwrite=True)
      context.setVariable(r"LD_LIBRARY_PATH", "", overwrite=True)
      context.setVariable(r"PV_PLUGIN_PATH", "", overwrite=True)
      context.setVariable(r"SalomeAppConfig", "", overwrite=True)
      context.setVariable(r"DYLD_LIBRARY_PATH", "", overwrite=True)
      context.setVariable(r"SHLIB_PATH", "", overwrite=True)
      context.setVariable(r"LIBPATH", "", overwrite=True)

    # [APPLI variables]
    context.setVariable(r"ABSOLUTE_APPLI_PATH", out_dir_Path + r"/EDF/s-salome-kernel", overwrite=True)
    context.setVariable(r"APPLI", out_dir_Path + r"/salome", overwrite=True)

    # Load all files env.d/*.py and call the module's init routine]

    extradir=out_dir_Path + r"/extra.env.d"

    if os.path.exists(extradir):
        import importlib
        import importlib.util
        sys.path.insert(0, os.path.join(os.getcwd(), extradir))
        for filename in sorted(
            filter(lambda x: os.path.isfile(os.path.join(extradir, x)),
                   os.listdir(extradir))):

            if filename.endswith(".py"):
                f = os.path.join(extradir, filename)
                module_name = os.path.splitext(os.path.basename(f))[0]
                _specs = importlib.util.find_spec(module_name)
                _module = importlib.util.module_from_spec(_specs)
                _specs.loader.exec_module(_module)
                _module.init(context, out_dir_Path)

    #[manage salome doc command]
    if len(args) >1 and args[0]=='doc':
        _showDoc(args[1:])
        return

    # Start SALOME, parsing command line arguments
    out, err, status = context.runSalome(args)
    sys.exit(status)

  except SalomeContextException as e:
    import logging
    logging.getLogger("salome").error(e)
    sys.exit(1)


if __name__ == "__main__":
  args = sys.argv[1:]
  main(args)
#
