
#  Extra modules can be set in environment variable SCBI_NG_EXTRA_MODULES.
#  The syntax is: <PLUGIN-1>(PATTERN-1)[:<PLUGIN-2>(PATTERN-2)]
#  where:
#     PLUGIN  : The SCBI plug-in name (must have an ng variant) to be
#               handled as extra module.
#     PATTERN : A regular expression of the module as found in the binary
#               archive. It is used to remove this from the NG environment
#               by matching the variable name and the variable values.

function s-salome-ng-extra-modules()
{
    for MOD in ${SCBI_EXTRA_NG_MODULES//:/ }; do
        local DEF=( $(get-extra-module-def $MOD) )
        echo ${DEF[0]}
    done
}

function s-salome-ng-common-modules()
{
    s-salome-ng-extra-modules

    echo s-salome-tar
    echo s-salome-configuration
    echo s-atomic
    echo s-paravisaddons-edf
    echo s-melissa
    echo s-python3-xlutils
    echo s-python-modules
    echo s-zcracks
    echo s-cgal
    echo s-padder
    echo s-gnuplot-py

    echo s-meshgems
}

function s-salome-ng-hydro-modules()
{
    echo s-hydro
    echo s-hydrosolver
    echo s-libecw2
    echo s-mumps
    echo s-scalapack
    echo s-gotm
    echo s-aed2
    echo s-metis-hydro
    echo s-telemac
    echo s-geos
}

function s-salome-ng-cfd-modules()
{
    echo s-coolprop
    echo s-libccmio
    echo s-saturne
    echo s-saturne-dbg
    echo s-cfd-study
    echo s-code-syrthes
    echo s-syrthes
}

function s-salome-ng-neptune-modules()
{
    echo s-neptune
    echo s-eos
}

function s-salome-ng-carmel-modules()
{
    echo s-carmel-study
}

function s-salome-ng-propagate-version()
{
    echo false
}

function setup-env-salome-ng()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    local APPDIR=$SCBI_BDIR/s-salome-ng/application

    #  THIS ROUTINE should be used to loop over all NEW dependencies (modules
    #  built on top of the binary archive) and patch the env_launch.sh
    #  to add the necessary configs.

    (
        local SFILE=""
        local PFILE=""
        local N=1

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        local KEEP_VAR=no

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            #  Compute relative directory

            local CURRENT_MODULE_VAR=${CURRENT_MODULE}_ROOT_INSTALL_DIR
            local REPLTO="\${${CURRENT_MODULE_VAR}}"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_EDF\}}"
            local REL_PDIR="${VALUE#$CURRENT_MODULE_INSTALL}"

            [[ $VAR == "SCBI_SALOME_BIN_ENV_SECTION" ]] && KEEP_VAR=yes

            #  s-salome-bin & s-salome-tar need a specific handling as
            #  the variables points to the binary install directories.

            if [[ $CURRENT_MODULE_NAME == "s-salome-bin" ]] ||
                   [[ $CURRENT_MODULE_NAME == "s-salome-tar" ]]
            then
                local REL_FROM="$SCBI_BDIR/s-salome-tar/build/install"
                local REL_DIR="${VALUE/$REL_FROM/\$\{root_dir\}}"
                local DVAR="r\"$REL_DIR\""
            fi

            #  We set values as some are used in depends modules like
            #  s-salome-bin using SALOME_BIN_APPLICATION set in s-salome-tar.

            local VSET="no"

            if [[ $ACTION == SET ]]; then
                export $VAR=$VALUE
                unset VSET
            fi

            #  For shell script
            #  Not that we always append to existing variables as some
            #  may have been set by the binary package's env_lauch.sh.

            [[ $KEEP_VAR == yes ]] &&
                case "$VAR" in
                    *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                    ;;

                    *)
                        if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                            echo export $VAR=${REL_DIR}${VSET:+:\$${VAR}} >> $SFILE
                        else
                            echo export $VAR=\"${REL_DIR}\"${VSET:+:\$${VAR}} >> $SFILE
                        fi
                        ;;
                esac

            #  For Python

            #  Remove possible leading directory separator

            local DVAR=""

            if [[ "$VALUE" == "$REL_PDIR" ]]; then
                DVAR="\"$VALUE\""
            else
                [[ ${REL_PDIR:0:1} == '/' ]] && REL_PDIR=${REL_PDIR:1}

                DVAR="os.path.join($CURRENT_MODULE_VAR, r\"$REL_PDIR\")"
            fi

            [[ $KEEP_VAR == yes ]] &&
                case "$VAR" in
                    C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*| \
                        *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                    ;;

                    PATH)
                        echo "   context.addToPath($DVAR)"             >> $PFILE
                        ;;
                    LD_LIBRARY_PATH)
                        echo "   context.addToLdLibraryPath($DVAR)"    >> $PFILE
                        ;;
                    PYTHONPATH)
                        echo "   context.addToPythonPath($DVAR)"       >> $PFILE
                        ;;
                    PV_PLUGIN_PATH|SalomeAppConfig|SMESH_MeshersList)
                        echo "   context.addToVariable(r\"$VAR\", $DVAR)" >> $PFILE
                        ;;
                    SALOME_MODULES)
                        echo "   os.environ[\"SALOME_MODULES\"] = os.getenv(\"SALOME_MODULES\") + \",\" + \"$VALUE\"" >> $PFILE
                    ;;
                    *)
                        echo "   context.setVariable(r\"$VAR\", $DVAR, overwrite=True)"     >> $PFILE
                        ;;
                esac
        }

        function mod-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            if [[ $module == "s-salome-bin" ]]; then
                KEEP_VAR=no
            else
                KEEP_VAR=yes
            fi

            FCT=$(get-hook $module $variant env)

            if [[ ! -z $FCT ]]; then
                CURRENT_MODULE_NAME=$module
                CURRENT_MODULE=${module//-/_}
                CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/build/install

                # Call <module>-env hook which will be using the add-to-var
                # above.

                if [[ ${CURRENT_MODULE_NAME} == "s-meshgems" ]]; then
                    NUM=99
                else
                    NUM=$(printf "%02d" ${N})
                fi

                SFILE="$APPDIR/extra.env.d/${NUM}_${CURRENT_MODULE}.sh"
                PFILE="$APPDIR/extra.env.d/${NUM}_${CURRENT_MODULE}.py"
                N=$(( N + 1 ))

                {
                    echo "# $module"
                    echo "export ROOT_EDF=\${out_dir_Path}/EDF"
                    echo "export root_dir=\${out_dir_Path}"
                    echo "${CURRENT_MODULE}_ROOT_INSTALL_DIR=\${ROOT_EDF}/${module}"
                } > $SFILE

                chmod a+x $SFILE

                {
                    echo "# $module"
                    echo "import os.path"
                    echo "def init(context, root_dir):"
                    echo "   ROOT_EDF=os.path.join(root_dir, r\"EDF\")"
                    echo "   ${CURRENT_MODULE}_ROOT_INSTALL_DIR=os.path.join(ROOT_EDF, r\"${module}\")"
                } > $PFILE

                $FCT $CURRENT_MODULE_INSTALL $TARGET $variant
            fi

            #  Handle possible ctest support

            FCT=$(get-hook $module $variant ctest-dir)

            if [[ ! -z $FCT ]]; then
                local BINDIR=$(basename $(ls -1d BINARIES-*))
                echo "SUBDIRS(../../../../../$($FCT EDF/$module))" \
                     >> $BINDIR/SALOME/bin/salome/test/CTestTestfile.cmake
            fi
        }

        #  Patch env_launch.sh
        #  to be able to call the extra.env.d/*.sh from env_launch.sh

        cat << EOF >> env_launch.sh
while read F; do
    source \$F
done < <(find \$out_dir_Path/extra.env.d/ -type f -name "[0-9]*.sh" | sort -V)
EOF

        #  The directory where the environment files are stored
        mkdir -p extra.env.d

        #  Override some possible values

        PFILE="extra.env.d/00_setup.py"

        echo "def init(context, root_dir):"                 > $PFILE
        echo '   context.setVariable(r"ROOT_SALOME_INSTALL", root_dir, overwrite=True)' >> $PFILE
        echo '   context.addToPythonPath(r"${SMESH_ROOT_DIR}/share/salome/plugins/smesh")' >> $PFILE
        echo '   context.addToPythonPath(r"${SMESH_ROOT_DIR}/share/salome/plugins/smesh/MacMesh")' >> $PFILE
        echo '   context.addToPythonPath(r"${SMESH_ROOT_DIR}/share/salome/plugins/smesh/Verima")' >> $PFILE

        SFILE="extra.env.d/00_setup.sh"

        echo "export ROOT_SALOME_INSTALL=\${out_dir_Path}" >> $SFILE
        #  keep current PATH setting
        PATH_set=IS_SET

        for-all-modules-with-meta mod-callback s-salome-ng
    )
}

function s-salome-ng-wrapup()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    (
        #  Clean-up previous installation if any

        rm -fr application
        mkdir application
        cd application

        if [[ "$(is-enabled application)" = "yes" ]] \
               || [[ "$(is-enabled installer)" = "yes" ]];
        then
            scbi --version > .scbi_versions.txt

            dlog salome-ng prepare the application directory

            #  Copy CEA's binaries

            cp -r $SCBI_BDIR/s-salome-tar/build/install/* .

            #  Add some build artifacts for traceability

            [[ ! -z $CI_JOB_NAME ]] &&
                echo CI_JOB_NAME $CI_JOB_NAME >> artifacts/gitlab-ci.data
            [[ ! -z $CI_PIPELINE_ID ]] &&
                echo CI_PIPELINE_ID $CI_PIPELINE_ID  >> artifacts/gitlab-ci.data

            #  Copy EDF's modules into sub-directory EDF

            mkdir EDF

            local MODS=$(call-variant-hooks modules $PREFIX $TARGET $VARIANT)

            for module in $(for-final-modules $MODS); do
                #  Skip s-salome-tar as it is the root install and already
                #  handled above.

                if [[ $module != "s-salome-tar" ]]; then
                    MODULE_PATH=$SCBI_BDIR/$module/build/install

                    if [[ -d $MODULE_PATH ]]; then
                        mkdir EDF/$module
                        cp -r $MODULE_PATH/* EDF/$module
                    fi
                fi
            done

            dlog salome-ng setup application environment

            setup-env-salome-ng $PREFIX $TARGET $VARIANT

            # is the installer to be created?

            res=0

            # compute the final installer script name

            local module_info=( $(get-module-ref s-salome-ng) )
            local module=${module_info[0]}
            local variant=${module_info[1]}
            local kind=${module_info[2]}
            local ref=${module_info[3]}

            # install some support scripts & patch version

            cp $SCBI_PLUGINS/support/install-meshgems-ng .
            cp $SCBI_PLUGINS/support/create_catalog_ng.sh .

            sed -i "s/<salome_version>/${ref#*-}/g" create_catalog_ng.sh
            chmod a+x create_catalog_ng.sh

            chmod a+x install-meshgems-ng

            if [[ $(is-enabled installer) ]]; then
                dlog salome generate self installer, may take some time ...

                # check that makeself is installed
                check-tool makeself
                if [[ $? != 0 ]]; then
                    dlog salome Required tool makeself missing
                    exit 1
                fi

                # create the .run auto-installer to be distributed

                host=$(hostname)

                if [[ $host =~ "crfront" ]] || [[ $host =~ "gafront" ]]; then
                    sed "s,__SALOMEVERSION__,$SALOME_PREREQUIS_VERSION,g" $SCBI_PLUGINS/support/install-setup-cluster-ng > setup
                else
                    sed "s,__SALOMEVERSION__,$SALOME_PREREQUIS_VERSION,g" $SCBI_PLUGINS/support/install-setup-ng > setup
                fi

                chmod a+x setup

                cp $SCBI_PLUGINS/support/servers.pvsc .

                cd $SCBI_BDIR/s-salome-ng

                local script_name=salome-$TARGET-$variant

                case $kind in
                    DEV)
                        script_name=$script_name-DEV
                        ;;
                    BRANCH|VERSION)
                        script_name=$script_name-$ref
                        ;;
                    *)
                        ;;
                esac

                # --sha256 in 2.4 only

                if [[ $(is-enabled xz) ]]; then
                    # -xz compress 40% more but is slow to compress
                    O_COMPRESS="--xz"
                else
                    O_COMPRESS="--bzip2"
                fi

                #  Create a temporary application containing the templates
                #  of the scripts such as omniidl, h5hlcc,...
                #  This temporary application is used for the .run creation

                rm -rf application_tmp
                cp -rf application application_tmp

                local TARDIR=$SCBI_BDIR/s-salome-tar/$TARGET-default/install
                local BINDIR=$(basename $(ls -1d $TARDIR/BINARIES-*))
                local ORIG_BINDIR="$TARDIR/$BINDIR"
                local TEMPL_BINDIR="__BINDIR__"

                #  Convert these scripts to template.

                for SCRIPTS in omniORB/bin/omniidl \
                                   hdf5/bin/h5hlcc hdf5/bin/h5cc \
                                   netcdf/lib/pkgconfig/netcdf.pc \
                                   PyQt/bin/pyuic5 \
                                   matplotlib/bin/f2py;
                do
                    sed -i "s,${ORIG_BINDIR},${TEMPL_BINDIR},g" \
                        application_tmp/$BINDIR/$SCRIPTS
                done

                for SCRIPTS in application_tmp/$BINDIR/openturns/bin/f2py* \
                                   application_tmp/$BINDIR/Python/bin/f2py* \
                                   application_tmp/$BINDIR/C3PO/bin/f2py*;
                do
                    sed -i "s,${ORIG_BINDIR},${TEMPL_BINDIR},g" $SCRIPTS
                done

                #  Convert these sip scripts to template.

                find application_tmp/$BINDIR/sip/bin -type f -name "*sip*" |
                    while read F; do
                        sed -i "s,$ORIG_BINDIR,${TEMPL_BINDIR},g" $F
                    done

                #  Convert these .la scripts to template.

                find application_tmp/$BINDIR/gcc/bin -type f -name "*.la*" |
                    while read F; do
                        sed -i "s,$ORIG_BINDIR,${TEMPL_BINDIR},g" $F
                    done

                #  Convert Makefile and Python system configuration
                #  scripts to template.

                find application_tmp/$BINDIR/Python -type f \
                     \( -name "Makefile" -o -name "_sysconfigdata*py" \) |
                    while read F; do
                        sed -i "s,$ORIG_BINDIR,${TEMPL_BINDIR},g" $F
                    done

                makeself $O_COMPRESS --tar-quietly \
                         application_tmp $script_name.run \
                         "SALOME Application" ./setup
                res=$?
                rm -rf application_tmp
            fi

            if [[ $res == 0 ]]; then
                true
            else
                false
            fi

        else
            true
        fi
    )
}
