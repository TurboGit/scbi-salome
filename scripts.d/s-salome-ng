
#  Extra modules can be set in environment variable SCBI_NG_EXTRA_MODULES.
#  The syntax is: <PLUGIN-1>(PATTERN-1)[:<PLUGIN-2>(PATTERN-2)]
#  where:
#     PLUGIN  : The SCBI plug-in name (must have an ng variant) to be
#               handled as extra module.
#     PATTERN : A regular expression of the module as found in the binary
#               archive. It is used to remove this from the NG environment
#               by matching the variable name and the variable values.

function s-salome-ng-extra-modules()
{
    for MOD in ${SCBI_EXTRA_NG_MODULES//:/ }; do
        local DEF=( $(get-extra-module-def $MOD) )
        echo ${DEF[0]}
    done
}

function s-salome-ng-modules()
{
    s-salome-ng-extra-modules

    echo s-salome-tar
    echo s-salome-configuration
    echo s-atomic
    echo s-paravisaddons-edf
    echo s-melissa
    echo s-python3-xlutils
    echo s-python-modules
    echo s-zcracks
    echo s-cgal
    echo s-padder
    echo s-gnuplot-py

    #  We put s-distene and s-meshgems here to be able to switch between
    #  3 versions of meshgems (3.12, 3.13, 3.14).
    echo s-distene
    echo s-meshgems
}

function setup-salome-ng-env()
{
    local PREFIX=$1
    local TARGET=$2

    local APPDIR=$SCBI_BDIR/s-salome-ng/application

    #  THIS ROUTINE should be used to loop over all NEW dependencies (modules
    #  built on top of the binary archive) and patch the env_launch.sh
    #  to add the necessary configs.

    (
        local SFILE=""
        local PFILE=""
        local N=1

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            #  Compute relative directory

            local CURRENT_MODULE_VAR=${CURRENT_MODULE}_ROOT_INSTALL_DIR
            local REPLTO="\${${CURRENT_MODULE_VAR}}"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_EDF\}}"
            local REL_PDIR="${VALUE#$CURRENT_MODULE_INSTALL}"

            #  s-salome-bin needs a specific handling as the variables
            #  points to the binary install directories.

            local KEEP_VAR=yes

            if [[ $CURRENT_MODULE_NAME == "s-salome-bin" ]]; then
                local REL_FROM="$SCBI_BDIR/s-salome-tar/build/install"
                local REL_DIR="${VALUE/$REL_FROM/\$\{root_dir\}}"
                local DVAR="r\"$REL_DIR\""

                #  And check if we want to keep the variable. We want
                #  only those added in s-salome-bin explicitly and not
                #  coming from env_launch.sh.

                case "$VAR" in
                    CMAKE_PREFIX_PATH|C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|LIBRARY_PATH|PATH)
                        ;;
                    *)
                        KEEP_VAR=no
                        ;;
                esac
            fi

            #  Remove possible leading directory separator

            [[ ${REL_PDIR:0:1} == '/' ]] && REL_PDIR=${REL_PDIR:1}

            #  We set values as some are used in depends modules like
            #  s-salome-bin using SALOME_BIN_APPLICATION set in s-salome-tar.

            local VSET="no"

            if [[ $ACTION == SET ]]; then
                export $VAR=$VALUE
                unset VSET
            fi

            #  For shell script
            #  Not that we always append to existing variables as some
            #  may have been set by the binary package's env_lauch.sh.

            [[ $KEEP_VAR == yes ]] &&
                case "$VAR" in
                    *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                    ;;

                    *)
                        if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                            echo export $VAR=${REL_DIR}${VSET:+:\$${VAR}} >> $SFILE
                        else
                            echo export $VAR=\"${REL_DIR}\"${VSET:+:\$${VAR}} >> $SFILE
                        fi
                        ;;
                esac

            #  For Python

            if [[ $CURRENT_MODULE_NAME == "s-salome-bin" ]]; then
                #  Do nothing for s-salome-bin in Python module. The whole environment is
                #  already part of salome main driver.
                return
            fi

            local DVAR="os.path.join($CURRENT_MODULE_VAR, r\"$REL_PDIR\")"

            case "$VAR" in
                C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*| \
                    *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                ;;

                PATH)
                    echo "   context.addToPath($DVAR)"                >> $PFILE
                    ;;
                LD_LIBRARY_PATH)
                    echo "   context.addToLdLibraryPath($DVAR)"       >> $PFILE
                    ;;
                PYTHONPATH)
                    echo "   context.addToPythonPath($DVAR)"          >> $PFILE
                    ;;
                PV_PLUGIN_PATH|SalomeAppConfig)
                    echo "   context.addToVariable(r\"$VAR\", $DVAR)" >> $PFILE
                    ;;
                SALOME_MODULES)
                    echo "   os.environ[\"SALOME_MODULES\"] = \
                    os.getenv(\"SALOME_MODULES\") + \
                    \",\" + \"$VALUE\""                               >> $PFILE
                    ;;
                *)
                    if [[ "$REL_PDIR" == "$VALUE" ]]; then
                        if [[ $VALUE == \"*\" ]]; then
                            echo "   context.setVariable(r\"$VAR\", r$VALUE, overwrite=True)" >> $PFILE
                        else
                            echo "   context.setVariable(r\"$VAR\", r\"$VALUE\", overwrite=True)" >> $PFILE
                        fi
                    else
                        echo "   context.setVariable(r\"$VAR\", $DVAR, overwrite=True)"     >> $PFILE
                    fi
                    ;;
            esac
        }

        function mod-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            #  Skip some s-salome-tar & s-salome-bin

            FCT=$(get-hook $module $variant env)

            if [[ ! -z $FCT ]]; then
                CURRENT_MODULE_NAME=$module
                CURRENT_MODULE=${module//-/_}
                CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/build/install

                # Call <module>-env hook which will be using the add-to-var
                # above.

                NUM=$(printf "%02d" ${N})

                SFILE="$APPDIR/extra.env.d/${NUM}_${CURRENT_MODULE}.sh"
                PFILE="$APPDIR/extra.env.d/${NUM}_${CURRENT_MODULE}.py"
                N=$(( N + 1 ))

                echo "# $module"                                   > $SFILE
                echo "export ROOT_EDF=\${out_dir_Path}/EDF"       >> $SFILE
                echo "export root_dir=\${out_dir_Path}"           >> $SFILE
                echo "${CURRENT_MODULE}_ROOT_INSTALL_DIR=\${ROOT_EDF}/${module}" >> $SFILE
                chmod a+x $SFILE

                echo "# $module"                                     > $PFILE
                echo "import os.path"                               >> $PFILE
                echo "def init(context, root_dir):"                 >> $PFILE
                echo "   ROOT_EDF=os.path.join(root_dir, r\"EDF\")" >> $PFILE
                echo "   ${CURRENT_MODULE}_ROOT_INSTALL_DIR=os.path.join(ROOT_EDF, r\"${module}\")" >> $PFILE

                $FCT $CURRENT_MODULE_INSTALL $TARGET $variant
            fi

            #  Handle possible ctest support

            FCT=$(get-hook $module $variant ctest-dir)

            if [[ ! -z $FCT ]]; then
                local BINDIR=$(basename $(ls -1d BINARIES-*))
                echo "SUBDIRS(../../../../../$($FCT EDF/$module))" \
                     >> $BINDIR/SALOME/bin/salome/test/CTestTestfile.cmake
            fi
        }

        #  Patch env_launch.sh
        #  to be able to call the extra.env.d/*.sh from env_launch.sh

        cat << EOF >> env_launch.sh
while read F; do
    source \$F
done < <(find \$out_dir_Path/extra.env.d/ -type f -name "[0-9]*.sh" | sort -V)
EOF

        #  The directory where the environment files are stored
        mkdir -p extra.env.d

        #  Override some possible values

        PFILE="extra.env.d/00_setup.py"

        echo "def init(context, root_dir):"                 > $PFILE
        echo '   context.setVariable(r"ROOT_SALOME_INSTALL", root_dir, overwrite=True)' >> $PFILE
        echo '   context.setVariable(r"MESHGEMS_VERSION", r"213", overwrite=True)' >> $PFILE
        echo '   context.setVariable(r"SALOME_MG_KEYGEN_LIB_PATH", r"https://meshgems-licence.retd.edf.fr/MESHGEMS" + r"${MESHGEMS_VERSION}", overwrite=True)' >> $PFILE
        echo '   context.addToPythonPath(r"${SMESH_ROOT_DIR}/share/salome/plugins/smesh")' >> $PFILE
        echo '   context.addToPythonPath(r"${SMESH_ROOT_DIR}/share/salome/plugins/smesh/MacMesh")' >> $PFILE
        echo '   context.addToPythonPath(r"${SMESH_ROOT_DIR}/share/salome/plugins/smesh/Verima")' >> $PFILE

        SFILE="extra.env.d/00_setup.sh"

        echo "export ROOT_SALOME_INSTALL=\${out_dir_Path}" >> $SFILE
        #  keep current PATH setting
        PATH_set=IS_SET

        for-all-modules-with-meta mod-callback s-salome-ng
    )
}

function s-salome-ng-wrapup()
{
    local PREFIX=$1
    local TARGET=$2

    (
        #  Clean-up previous installation if any

        rm -fr application
        mkdir application
        cd application

        if [[ "$(is-enabled application)" = "yes" ]] \
               || [[ "$(is-enabled installer)" = "yes" ]];
        then
            scbi --version > .scbi_versions.txt

            dlog salome-ng prepare the application directory

            #  Copy CEA's binaries

            cp -r $SCBI_BDIR/s-salome-tar/build/install/* .

            #  Add some build artifacts for traceability

            [[ ! -z $CI_JOB_NAME ]] &&
                echo CI_JOB_NAME $CI_JOB_NAME >> artifacts/gitlab-ci.data
            [[ ! -z $CI_PIPELINE_ID ]] &&
                echo CI_PIPELINE_ID $CI_PIPELINE_ID  >> artifacts/gitlab-ci.data

            #  Copy EDF's modules into sub-directory EDF

            mkdir EDF

            for module in $(for-final-modules $(s-salome-ng-modules)); do
                #  Skip s-salome-tar as it is the root install and already
                #  handled above.

                if [[ $module != "s-salome-tar" ]]; then
                    MODULE_PATH=$SCBI_BDIR/$module/build/install

                    if [[ -d $MODULE_PATH ]]; then
                        mkdir EDF/$module
                        cp -r $MODULE_PATH/* EDF/$module
                    fi
                fi
            done

            dlog salome-ng setup application environment

            setup-salome-ng-env $PREFIX $TARGET

            # is the installer to be created?

            res=0

            # compute the final installer script name

            local module_info=( $(get-module-ref s-salome-ng) )
            local module=${module_info[0]}
            local variant=${module_info[1]}
            local kind=${module_info[2]}
            local ref=${module_info[3]}

            # install catalog script & patch version

            cp $SCBI_PLUGINS/support/create_catalog_ng.sh .

            sed -i "s/<salome_version>/${ref#*-}/g" create_catalog_ng.sh
            chmod a+x create_catalog_ng.sh

            # patch salome launcher to be able to switch between 3 versions of meshgems (3.12, 3.13, 3.14)

            patch -p0 < $SCBI_PLUGINS/patches/salome_mglic.patch

            if [[ $(is-enabled installer) ]]; then
                dlog salome generate self installer, may take some time ...

                # check that makeself is installed
                check-tool makeself
                if [[ $? != 0 ]]; then
                    dlog salome Required tool makeself missing
                    exit 1
                fi

                # create the .run auto-installer to be distributed

                sed "s,__SALOMEVERSION__,$SALOME_PREREQUIS_VERSION,g" $SCBI_PLUGINS/support/install-setup-ng > setup
                chmod a+x setup

                cp $SCBI_PLUGINS/support/servers.pvsc .

                cp $SCBI_PLUGINS/support/salome_hpc_visu_servers.py .
                chmod a+x salome_hpc_visu_servers.py

                cd $SCBI_BDIR/s-salome-ng

                local script_name=salome-$TARGET-$variant

                case $kind in
                    DEV)
                        script_name=$script_name-DEV
                        ;;
                    BRANCH|VERSION)
                        script_name=$script_name-$ref
                        ;;
                    *)
                        ;;
                esac

                # --sha256 in 2.4 only

                if [[ $(is-enabled xz) ]]; then
                    # -xz compress 40% more but is slow to compress
                    O_COMPRESS="--xz"
                else
                    O_COMPRESS="--bzip2"
                fi

                #  Create a temporary application containing the templates
                #  of the scripts such as omniidl, h5hlcc,...
                #  This temporary application is used for the .run creation

                rm -rf application_tmp
                cp -rf application application_tmp

                local TARDIR=$SCBI_BDIR/s-salome-tar/$TARGET-default/install
                local BINDIR=$(basename $(ls -1d $TARDIR/BINARIES-*))
                local ORIG_BINDIR="$TARDIR/$BINDIR"
                local TEMPL_BINDIR="__BINDIR__"

                #  Convert these scripts to template.

                for SCRIPTS in omniORB/bin/omniidl \
                                   hdf5/bin/h5hlcc hdf5/bin/h5cc \
                                   netcdf/lib/pkgconfig/netcdf.pc \
                                   PyQt/bin/pyuic5;
                do
                    sed -i "s,${ORIG_BINDIR},${TEMPL_BINDIR},g" \
                        application_tmp/$BINDIR/$SCRIPTS
                done

                #  Convert these sip scripts to template.

                find application_tmp/$BINDIR/sip/bin -type f -name "*sip*" |
                    while read F; do
                        sed -i "s,$ORIG_BINDIR,${TEMPL_BINDIR},g" $F
                    done

                #  Convert Makefile and Python system configuration
                #  scripts to template.

                find application_tmp/$BINDIR/Python -type f \
                     \( -name "Makefile" -o -name "_sysconfigdata*py" \) |
                    while read F; do
                        sed -i "s,$ORIG_BINDIR,${TEMPL_BINDIR},g" $F
                    done

                makeself $O_COMPRESS --tar-quietly \
                         application_tmp $script_name.run \
                         "SALOME Application" ./setup
                res=$?
                rm -rf application_tmp
            fi

            if [[ $res == 0 ]]; then
                true
            else
                false
            fi

        else
            true
        fi
    )
}
