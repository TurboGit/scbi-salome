
# Note that on Debian-9 sphinx-intl is not present. To install it one need
# to allow one package from Buster to be installed:
#
# Package: sphinx-intl
# Pin: release n=buster
# Pin-Priority: 0

function salome-v95-plan()
{
    echo dev
}

function salome-main-modules()
{
    echo salome-kernel
    echo salome-gui
    echo salome-plugins
    echo shaper
    echo shaperstudy
    echo geom
    echo smesh
    echo paravis
    echo fields
    echo yacs
    echo salome-adao
    echo ydefx
    echo salome-eficas
    echo salome-jobmanager
    echo homard
    echo atomic
    echo atomgen
    echo hexablock
    echo atomsolv
    echo calculator
    echo genericsolver
    echo hello
    echo pyhello
    echo light
    echo pylight
    echo dsccode
    echo melidefx
    echo salome-openturns
    echo non-regression-tests
    echo clustertests
}

function salome-prerequisite-modules()
{
    echo adao
    echo adao-interface
    echo samples
    echo s-omniorb
    echo s-python-omniorb
    echo eficas-tools
    echo occt
    echo yacsgen
    echo medfichier
    echo medcoupling
    echo libbatch
    echo py2cpp
    echo meshgems
    echo planegcs
    echo ospray
    echo embree
    echo paraview
    echo gmsh
    echo paravisaddons
    echo paravisaddons-common
    echo persalys
    echo netgen
    echo openturns
    echo openturns-fftw
    echo openturns-mixmod
    echo openturns-morris
    echo openturns-pmml
    echo openturns-robopt
    echo openturns-subsetinverse
    echo openturns-svm
    echo openturns-wrapy
    echo uranie
    echo s-root
    echo homard-tool
    echo s-zeromq
    echo melissa
    echo s-python3-nlopt
    echo s-python3-xlutils
    echo s-rkcommon
    echo s-openvkl
}

function salome-modules()
{
    salome-main-modules
    salome-prerequisite-modules
    echo salome-configuration
}

function salome-prefix()
{
    echo NONE
}

# support for SALOME application creation

declare -g MAIN_MODULE_LIST=()

function is-main-module()
{
    local MODULE=$1

    # Not yet cacched

    if [[ -z $MAIN_MODULE_LIST ]]; then
        for M in $(for-final-modules $(salome-main-modules)); do
            MAIN_MODULE_LIST+=($M)
        done
    fi

    for M in ${MAIN_MODULE_LIST[@]}; do
        if [[ "$M" = "$MODULE" ]]; then
            return 0
        fi
    done

    return 1
}

function build-salome-prerequisites()
{
    local PREFIX=$1
    local TARGET=$2

    (
        FILE=salome_prerequisites.sh

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function add-to-var()
        {
            local VAR=$1
            local DIR=$2

            # compute relative directory
            local REPLTO="\${${CURRENT_MODULE}_ROOT_INSTALL_DIR}"
            local REL_TMP="${DIR/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_EXTERNAL\}}"

            is-main-module $CURRENT_MODULE_NAME

            if [[ $? = 0 ]]; then
                REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_INSTALL\}}"
            fi

            case "$VAR" in
                C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*| \
                    *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                ;;

                *)
                    VSET=${VAR}_set
                    echo export $VAR=${REL_DIR}${!VSET:+:\$${VAR}} >> $FILE

                    # mark $VAR as set to ensure that the previous value
                    # will be added on next call ${!VAR...} above.
                    export ${VAR}_set=IS_SET
                    ;;
            esac
        }

        function env-callback()
        {
            local MODULE=$1
            local MODREF=$2
            local IS_ROOT=$3
            local IS_EXT=$4

            fn-exists $MODULE-env
            if [[ $? = 0 ]]; then
                CURRENT_MODULE_NAME=$MODULE
                CURRENT_MODULE=${MODULE//-/_}
                CURRENT_MODULE_INSTALL=$SCBI_BDIR/$MODULE/build/install

                echo ""          >> $FILE
                echo "# $MODULE" >> $FILE

                echo -n "export ${CURRENT_MODULE}_ROOT_INSTALL_DIR=" >> $FILE

                is-main-module $MODULE

                if [[ $? = 0 ]]; then
                    echo "\${ROOT_INSTALL}"                         >> $FILE
                else
                    echo "\${ROOT_EXTERNAL}/${MODULE}"              >> $FILE
                fi

                $MODULE-env $CURRENT_MODULE_INSTALL $TARGET
            fi
        }

        echo                                                            > $FILE
        echo "export ROOT_INSTALL=\$(dirname \$(which \$BASH_SOURCE))" >> $FILE
        echo "export ROOT_EXTERNAL=\$ROOT_INSTALL/external"            >> $FILE

        # keep current PATH setting
        PATH_set=IS_SET

        for-all-modules-with-meta env-callback salome

	chmod u+x $FILE
    )
}

function build-salome-context()
{
    local PREFIX=$1
    local TARGET=$2

    (
        FILE=salome_context.cfg

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function add-to-var()
        {
            local VAR=$1
            local DIR=$2

            # compute relative directory
            local REPLTO="%(${CURRENT_MODULE}_ROOT_INSTALL_DIR)s"
            local REL_TMP="${DIR/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/%(ROOT_EXTERNAL)s}"

            is-main-module $CURRENT_MODULE_NAME

            if [[ $? = 0 ]]; then
                REL_DIR="${REL_TMP/$SCBI_BDIR/%(ROOT_INSTALL)s}"
            fi

            case "$VAR" in
                LD_LIBRARY_PATH|PYTHONPATH|PATH|QT_PLUGIN_PATH|PV_PLUGIN_PATH)
                    echo "ADD_TO_$VAR: ${REL_DIR}" >> $FILE
                    ;;

                C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*\
                    |*INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                    ;;

                *)
                    echo $VAR=$REL_DIR >> $FILE
                    ;;
            esac
        }

        function env-callback()
        {
            local MODULE=$1
            local MODREF=$2
            local IS_ROOT=$3
            local IS_EXT=$4

            fn-exists $MODULE-env
            if [[ $? = 0 ]]; then
                CURRENT_MODULE_NAME=$MODULE
                CURRENT_MODULE=${MODULE//-/_}
                CURRENT_MODULE_INSTALL=$SCBI_BDIR/$MODULE/build/install

                echo ""          >> $FILE
                echo "# $MODULE" >> $FILE

                echo -n "${CURRENT_MODULE}_ROOT_INSTALL_DIR="  >> $FILE

                is-main-module $MODULE

                if [[ $? = 0 ]]; then
                    echo "%(ROOT_INSTALL)s"                   >> $FILE
                else
                    echo "%(ROOT_EXTERNAL)s/${MODULE}"        >> $FILE
                fi

                $MODULE-env $CURRENT_MODULE_INSTALL $TARGET
            fi
        }

        echo "[SALOME Configuration]"                                    > $FILE
        echo "ROOT_INSTALL=\${ROOT_SALOME_INSTALL}"                     >> $FILE
        echo "ROOT_EXTERNAL=%(ROOT_INSTALL)s/external"                  >> $FILE
        echo "LC_NUMERIC=C"                                             >> $FILE
        echo "ADD_TO_SALOME_PLUGINS_PATH:\"%(ROOT_EXTERNAL)s/plugins\"" >> $FILE
        echo "ADD_TO_PV_PLUGIN_PATH: \"%(ROOT_INSTALL)s/lib/paraview\"" >> $FILE

        for-all-modules-with-meta env-callback salome
    )
}

function build-config-appli()
{
    local PREFIX=$1
    local TARGET=$2

    FILE=config_appli.xml

    cat <<EOF > $FILE
<application>
   <prerequisites path='$PWD/salome_prerequisites.sh'/>
   <context path='$PWD/salome_context.cfg'/>
   <modules>
EOF

    # Note that the MODULE_NAME must have specific naming by convention,
    # so we cannot use the plugin module name directly. The following
    # sed commands are there to convert the plugin names to the expected
    # names. Finally we convert the name in capital letters.

    for module in $(for-final-modules $(salome-main-modules)); do
        MODULE_NAME=$(echo $module | \
                             sed 's/salome-//g;s/-plugin/plugin/g' | \
                             tr [a-z] [A-Z])
        MODULE_PATH=$SCBI_BDIR/$module/build/install

        echo "      <module name='$MODULE_NAME'"    >> $FILE
        echo "              path='$MODULE_PATH'/>"  >> $FILE
    done

    echo "   </modules>"                            >> $FILE

    # Generate extra configuration for SAMPLES & MEDCOUPLING

    for module in $(salome-prerequisite-modules); do
        MODULE_PATH=$SCBI_BDIR/$module/build/install

        if [[ "$module" == "samples" ]]; then
            echo "   <samples path=\"$MODULE_PATH\"/>"        >> $FILE
        elif [[ "$module" == "medcoupling" ]]; then
            echo "   <extra_tests>"                           >> $FILE
            echo "      <extra_test name='MEDCOUPLING'"       >> $FILE
            echo "             path=\"$MODULE_PATH/tests\"/>" >> $FILE
            echo "   </extra_tests>"                          >> $FILE
        fi
    done

    echo "</application>"                                     >> $FILE
}

function salome-wrapup()
{
    local PREFIX=$1
    local TARGET=$2

    # Finaly we create here:
    #
    # - salome_prerequisites.sh
    # - salome_context.cfg
    # - config_appli.xml
    # - the application directory
    # - the self installer

    (
        rm -fr application
        mkdir application
        cd application

        dlog salome create application context

        # generate salome_prerequisites.sh shell script
        build-salome-prerequisites $PREFIX $TARGET

        # generate salome_context.cfg script
        build-salome-context $PREFIX $TARGET

        # generate config_appli.xml
        build-config-appli $PREFIX $TARGET

        if [[ "$(is-enabled application)" = "yes" ]] \
               || [[ "$(is-enabled installer)" = "yes" ]];
        then
            dlog salome generate application
            # generate the application directory
            $SCBI_BDIR/salome-kernel/build/install/bin/salome/appli_gen.py

            if [[ $? != 0 ]]; then
                elog salome Error while running appli_gen
                exit 1
            fi

            # salome application root dir
            APP_DIR=$SCBI_BDIR/salome

            # replace all symlinks outside the APP_DIR by a copy of
            # the corresponding files/directories. This makes the
            # application directory self contained.

            dlog salome fix links to be relative to application directory

            cd $APP_DIR

            find . -type l | while read link; do
                value=$(realpath --relative-to=$APP_DIR $link)

                # if link to level above $APP_DIR, copy

                if [[ ${value:0:3} = "../" ]]; then
                    rm -f $link
                    cp -r $value ${link}
                fi
            done

            local APP=$SCBI_BDIR/salome/application
            cd $APP

            # generate the scbi_versions.txt for tracability

            scbi --version > .scbi_versions.txt

            # replace toplevel links to reference local scripts

            for file in envd getAppliPath.py kill_remote_containers.py \
                        runRemote.sh update_catalogs.py .bashrc .salome_run;
            do
                rm -f $file
                ln -s ./bin/salome/appliskel/$file $file
            done

            # copy module dev support

            dlog salome "copy the modules' dev support files"

            for module in $(for-final-modules $(salome-main-modules)); do
                MODULE_PATH=$SCBI_BDIR/$module/build/install

                for dir in include salome_adm adm_local; do
                    if [[ -d $MODULE_PATH/$dir ]]; then
                        cp -r $MODULE_PATH/$dir .
                    fi
                done
            done

            # copy all prerequisites

            dlog salome copy the pre-requisites

            mkdir external

            for p in $(salome-prerequisite-modules); do
                # Some module may not be present if they have been skiped
                # in build plan (:skip)
                if [[ -d $SCBI_BDIR/$p/build/install ]]; then
                    cp -r $SCBI_BDIR/$p/build/install external/$p
                fi
            done

            # finaly replace hard-coded path in text files

            dlog salome fix absolute references in source files

            salome-replace-full-path

            # is the installer to be created?

            res=0

            # compute the final installer script name

            local module_info=( $(get-module-ref salome) )
            local module=${module_info[0]}
            local variant=${module_info[1]}
            local kind=${module_info[2]}
            local ref=${module_info[3]}

            # install catalog script & patch version

            cp $SCBI_DEFS/support/create_catalog.py $APP/

            sed -i "s/<salome_version>/$ref/g" $APP/create_catalog.py
            chmod a+x $APP/create_catalog.py

            if [[ $(is-enabled installer) ]]; then
                dlog salome generate self installer, may take some time ...

                # check that makeself is installed
                check-tool makeself
                if [[ $? != 0 ]]; then
                    dlog salome Required tool makeself missing
                    exit 1
                fi

                # create the .run auto-installer to be distributed

                cp $SCBI_DEFS/support/install-setup $APP/setup
                chmod a+x $APP/setup

                cp $SCBI_DEFS/support/servers.pvsc $APP/

                cp $SCBI_DEFS/support/salome_hpc_visu_servers.py $APP/
                chmod a+x $APP/salome_hpc_visu_servers.py

                cd $SCBI_BDIR/salome

                local script_name=salome-$TARGET-$variant

                case $kind in
                    DEV)
                        script_name=$script_name-dev
                        ;;
                    BRANCH|VERSION)
                        script_name=$script_name-$ref
                        ;;
                    *)
                        ;;
                esac

                # --sha256 in 2.4 only

                if [[ $(is-enabled xz) ]]; then
                    # -xz compress 40% more but is slow to compress
                    O_COMPRESS="--xz"
                else
                    O_COMPRESS="--bzip2"
                fi

                makeself $O_COMPRESS --tar-quietly \
                         application $script_name.run \
                         "SALOME Application" ./setup
                res=$?
            fi

            # check for python3
            #
            if [[ -z "$(python --version 2>&1 | grep ' 3\.')" ]]; then
                dlog python2 is default, checking for python3
                if [[ -f /usr/bin/python3 ]]; then
                    dlog found python3 in /usr/bin/python3, setuup links
                    (
                        cd $APP
                        rm -f ./bin/python ./bin/salome/python
                        ln -s /usr/bin/python3 ./bin/python
                        ln -s /usr/bin/python3 ./bin/salome/python
                    )
                else
                    dlog cannot found a python3 installation.
                    dlog SALOME will not work properly.
                fi
            fi

            if [[ $res == 0 ]]; then
                true
            else
                false
            fi

        else
            true
        fi
    )
}

function salome-replace-full-path()
{
    cd $SCBI_BDIR/salome/application

    #
    # PYTHON
    #

    # FROM/TO patterns
    local ENV="os.environ['ROOT_SALOME_INSTALL']"

    local PYFROM1="r\"$SCBI_BDIR.*/idl/omniORB/\(.*\.idl\)"
    local PYTO1="$ENV + r\"/external/omniorb/share/idl/omniORB/\1"

    local PYFROM2="r\"$SCBI_BDIR.*/idl/\(.*\.idl\)"
    local PYTO2="$ENV + r\"/idl/salome/\1"

    local PYFROM3=" $SCBI_BDIR/\([^/]*\)/build/\(install\|build\)/\?\([^ ]*[ ]\)"
    local PYTO3=" \' + $ENV + \'/external/\1/\2 "

    local PYFROM4=" $SCBI_BDIR/\([^/]*\)/build/\(install\|build\)/\?\([^\']*\)"
    local PYTO4=" \' + $ENV + \'/external/\1/\2"

    local PYFROM5="[']$SCBI_BDIR/\([^/]*\)/build/\(install\|build\)/\?\([^;\']*\)"
    local PYTO5="$ENV + \'/external/\1/\2"

    # Note that we add os in the first import as needed to get environment

    find . -name "*.py" |
        while read file; do
            grep -q "^[^#]*$SCBI_BDIR" $file
            [[ $? = 0 ]] &&
                sed -i '0,/^import /{s/^import /import os, /}' $file \
                    &&
                sed -i "s,$PYFROM1,$PYTO1,g; \
                        s,$PYFROM2,$PYTO2,g; \
                        s,$PYFROM3,$PYTO3,g; \
                        s,$PYFROM4,$PYTO4,g; \
                        s,$PYFROM5,$PYTO5,g" $file
        done

    #
    # CMAKE
    #

    # FROM/TO patterns
    local ENV="\${ROOT_SALOME_INSTALL}"

    local CMAKEFROM="$SCBI_BDIR/\([^/]*\)/build/\(install\|build\)/\?\([^;\"]*\)"
    local CMAKETO="$ENV/external/\1/\2"

    find . -name "*.cmake" |
        while read file; do
            grep -q "$SCBI_BDIR" $file
            [[ $? = 0 ]] && sed -i "s,$CMAKEFROM,$CMAKETO,g" $file
        done

    # Some other files have references to root dirs *.pc *.la *.prl
}
