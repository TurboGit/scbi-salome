
#  Extra modules can be set in environment variable SCBI_EXTRA_NG_MODULES.
#  The syntax is: <PLUGIN-1>(PATTERN-1)[:<PLUGIN-2>(PATTERN-2)]
#  where:
#     PLUGIN  : The SCBI plug-in name (must have an ng variant) to be
#               handled as extra module.
#     PATTERN : A regular expression of the module as found in the binary
#               archive. It is used to remove this from the NG environment
#               by matching the variable name and the variable values.

function s-salome-ng-extra-modules()
{
    for MOD in ${SCBI_EXTRA_NG_MODULES//:/ }; do
        local DEF=( $(get-extra-module-def $MOD) )
        echo ${DEF[0]}
    done
}

function s-salome-common-modules()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    #  We need the extra modules to be handled first because they are
    #  supposed to replace some modules from the binary archive and
    #  may be a dependency from other modules listed after.

    $(has-variant $VARIANT ng) &&
        s-salome-ng-extra-modules

    echo s-salome-configuration
    echo s-atomic
    echo s-paravisaddons-edf
    echo s-melissa
    echo s-zcracks
    echo s-cgal
    echo s-padder
    echo s-tefluide
    echo s-meshgems
    echo s-python-modules
}

function s-salome-default-modules()
{
    echo s-cmake
    echo s-salome-kernel
    echo s-salome-gui
    echo s-salome-plugins
    echo s-shaper
    echo s-shaper-study
    echo s-geom
    echo s-smesh
    echo s-paravis
    echo s-fields
    echo s-yacs
    echo s-ydefx
    echo s-salome-eficas
    echo s-salome-jobmanager
    echo s-homard
    echo s-atomgen
    echo s-hexablock
    echo s-atomsolv
    echo s-calculator
    echo s-pycalculator
    echo s-genericsolver
    echo s-hello
    echo s-pyhello
    echo s-light
    echo s-pylight
    echo s-dsccode
    echo s-melidefx
    echo s-salome-openturns
    echo s-non-regression-tests
    echo s-clustertests

    echo s-adao
    echo s-adao-interface
    echo s-samples
    echo s-omniorb
    echo s-python-omniorb
    echo s-eficas-tools
    echo s-occt
    echo s-yacsgen
    echo s-medfichier
    echo s-medcoupling
    echo s-libbatch
    echo s-py2cpp
    echo s-planegcs
    echo s-ospray
    echo s-embree
    echo s-paraview
    echo s-gmsh
    echo s-paravisaddons-common
    echo s-persalys
    echo s-netgen
    echo s-openturns
    echo s-openturns-plugins
    echo s-uranie
    echo s-root
    echo s-homard-tool
    echo s-zeromq
    echo s-python3-nlopt
    echo s-rkcommon
    echo s-openvkl
    echo s-cgns
    echo s-ttk
    echo s-qt
    echo s-catalyst
    echo s-pyqt
    echo s-pyqt-sip
    echo s-sip
    echo s-topiivol
    echo s-component
}

function s-salome-ng-modules()
{
    #  The plug-in s-salome-bin must be explicitly set here as it is
    #  a build dependency on all plug-ins but it also must be available
    #  at run-time as it contains settings for many prerequisites.
    echo s-salome-bin

    echo s-salome-tar
}

function s-salome-hydro-modules()
{
    echo s-hydro
    echo s-hydrosolver
    echo s-libecw2
    echo s-mumps
    echo s-scalapack
    echo s-gotm
    echo s-aed2
    echo s-metis-hydro
    echo s-telemac
}

function s-salome-cfd-modules()
{
    echo s-coolprop
    echo s-libccmio
    echo s-saturne
    echo s-saturne-dbg
    echo s-cfd-study
    echo s-code-syrthes
    echo s-syrthes
}

function s-salome-neptune-modules()
{
    echo s-neptune
    echo s-eos
}

function s-salome-carmel-modules()
{
    echo s-carmel-study
}

function s-salome-bim-modules()
{
    echo s-building-is
    echo s-ifc-open-shell
    echo s-dataio
}

function s-salome-logger-modules()
{
    echo s-logger
}

function s-salome-core-modules()
{
    s-salome-bim-modules
    s-salome-logger-modules
}

function s-salome-propagate-version()
{
    echo false
}

function setup-env-salome()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    local APPDIR=$SCBI_BDIR/s-salome/$TARGET-$VARIANT

    #  If BINARIES-* not found, this is a full EDF build
    if [[ -z $SALOME_BINARY_DIR ]]; then
        SBINDIR=EDF/s-salome-kernel
    else
        SBINDIR=$SALOME_BINARY_DIR/SALOME
    fi

    #  THIS ROUTINE should be used to loop over all NEW dependencies (modules
    #  built on top of the binary archive) and patch the env_launch.sh
    #  to add the necessary configs.

    (
        local SFILE=""
        local PFILE=""
        local N=1

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        local KEEP_VAR=no
        declare -A ENVSET=()

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            #  Note that this implementation do not take into account
            #  the prepend vs add/append.  We should already reapply a
            #  prepend if the last action for the variable was not a
            #  prepend. In the Shell & Python generation we should
            #  also always take into account the prepend vs add/append
            #  (we do this only for PV_PLUGIN_PATH, SalomeAppConfig
            #  and SMESH_MeshersList variables in the Python case.

            local KEY="${ACTION}.${VAR}"
            local CVALUE="${ENVSET[$KEY]}"

            [[ "${CVALUE}" =~ "|${VALUE}|" ]] && return

            ENVSET+=([$KEY]="|${VALUE}|${CVALUE}")

            #  Special case, do not add /usr/bin to PATH from native modules.
            #  This PATH will be at the end of the PATH anyway and we do want
            #  to pick other tools compiled first.

            [[ ${VAR} == "PATH" ]] && [[ ${VALUE} == "/usr/bin" ]] && return

            #  Compute relative directory

            local CURRENT_MODULE_VAR=${CURRENT_MODULE}_ROOT_INSTALL_DIR
            local REPLTO="\${${CURRENT_MODULE_VAR}}"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_EDF\}}"
            local REL_PDIR="${VALUE#$CURRENT_MODULE_INSTALL}"

            [[ $VAR == "SCBI_SALOME_BIN_ENV_SECTION" ]] && KEEP_VAR=yes

            #  s-salome-bin & s-salome-tar need a specific handling as
            #  the variables points to the binary install directories.

            if [[ $CURRENT_MODULE_NAME == "s-salome-bin" ]] ||
                   [[ $CURRENT_MODULE_NAME == "s-salome-tar" ]]
            then
                local REL_FROM="$SCBI_BDIR/s-salome-tar/$SCBI_TARGET-$SALOME_TAR_VARIANT/install"
                local SFX_DIR="${VALUE#$REL_FROM/}"
                local SFX_DIR="${SFX_DIR#$REL_FROM}"
                # For shell:
                local REL_DIR="${VALUE/$REL_FROM/\$\{root_dir\}}"
                # For Python:
                local DVAR="os.path.join(root_dir, r\"$SFX_DIR\")"

            elif [[ "$VALUE" == "$REL_PDIR" ]]; then
                local DVAR="\"$VALUE\""
            else
                [[ ${REL_PDIR:0:1} == '/' ]] &&
                    local REL_PDIR=${REL_PDIR:1}

                local DVAR="os.path.join($CURRENT_MODULE_VAR, r\"$REL_PDIR\")"
            fi

            #  We set values as some are used in depends modules like
            #  s-salome-bin using SALOME_BIN_APPLICATION set in s-salome-tar.

            local VSET="no"

            if [[ $ACTION == SET ]]; then
                export $VAR=$VALUE
                unset VSET
            fi

            #  For shell script
            #  Not that we always append to existing variables as some
            #  may have been set by the binary package's env_lauch.sh.

            [[ $KEEP_VAR == yes ]] &&
                {
                    if [[ $ACTION == REMOVE ]]; then
                        if [[ $SCBI_IS_WINDOWS == yes ]] && [[ $VAR != "PATH" ]]; then
                            echo remove-from-string-sep \"$VAR\" \"$VALUE\" \";\"
                        else
                            echo remove-from-string-sep \"$VAR\" \"$VALUE\" \":\"
                        fi
                    else
                        case "$VAR" in
                            *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                            ;;

                            *)
                                if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                                    echo export $VAR=${REL_DIR}${VSET:+:\$${VAR}}
                                else
                                    echo export $VAR=\"${REL_DIR}\"${VSET:+:\$${VAR}}
                                fi
                                ;;
                        esac
                    fi
                } >> $SFILE

            #  For Python

            [[ $KEEP_VAR == yes ]] &&
                {
                    if [[ $ACTION == REMOVE ]]; then
                        echo "   context.removeFromVariable(r\"$VAR\", r\"$VALUE\")"
                    else
                        case "$VAR" in
                            C_INCLUDE_PATH|INCLUDE|LIB|CPLUS_INCLUDE_PATH|CMAKE_*| \
                                *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                            ;;

                            PATH)
                                echo "   context.addToPath($DVAR)"
                                ;;
                            LD_LIBRARY_PATH)
                                echo "   context.addToLdLibraryPath($DVAR)"
                                ;;
                            PYTHONPATH)
                                echo "   context.addToPythonPath($DVAR)"
                                ;;
                            PV_PLUGIN_PATH|SalomeAppConfig|SMESH_MeshersList)
                                if [[ $ACTION == PREPEND ]]; then
                                    echo "   context.addToVariable(r\"$VAR\", $DVAR)"
                                else
                                    echo "   context.appendVariable(r\"$VAR\", $DVAR)"
                                fi
                                ;;
                            SALOME_MODULES)
                                echo "   os.environ[\"SALOME_MODULES\"] = os.getenv(\"SALOME_MODULES\") + \",\" + \"$VALUE\""
                                ;;
                            *)
                                echo "   context.setVariable(r\"$VAR\", $DVAR, overwrite=True)"
                                ;;
                        esac
                    fi
                } >> $PFILE
        }

        function mod-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local DEPENDS_KIND=$4
            local IS_EXT=$5
            local IS_META=$6
            local IS_AGGREGATED=$7

            local IS_AGGREGATE=false

            #  No env setup aggregated modules and build dependencies

            [[ $DEPENDS_KIND != default ]] || [[ $IS_AGGREGATED == true ]] &&
                return

            #  Check if aggregate module and so if env of aggregated modules must
            #  be set in it.

            if [[ $IS_META == true ]]; then
                #  check if aggregate module

                is-meta-aggregate-module IS_AGGREGATE $MODREF
            fi

            local module_info=()
            get-module-ref module_info $MODREF $FORMODULE
            local module=${module_info[0]}
            local variant=${module_info[1]}

            if [[ $module == "s-salome-bin" ]]; then
                KEEP_VAR=no
            else
                KEEP_VAR=yes
            fi

            #  Check if the module has been installed into EDF
            #  directory. If not it is probably because it is an
            #  aggregated module.

            [[ ! -d $APPDIR/EDF/$module ]] &&
                [[ $module != "s-salome-bin" ]] &&
                [[ $module != "s-salome-tar" ]] &&
                return

            #  Initialize env script

            CURRENT_MODULE_NAME=$module
            CURRENT_MODULE=${module//-/_}
            CURRENT_MODULE_DIR=$module
            CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/install

            if [[ ${CURRENT_MODULE_NAME} == "s-meshgems" ]]; then
                NUM=998
            else
                NUM=$(printf "%03d" ${N})
            fi

            SFILE="$APPDIR/extra.env.d/${NUM}_${CURRENT_MODULE}.sh"
            PFILE="$APPDIR/extra.env.d/${NUM}_${CURRENT_MODULE}.py"
            N=$(( N + 1 ))

            {
                echo "# $(get-module-name $module)"
                echo "export ROOT_EDF=\${out_dir_Path}/EDF"
                echo "export root_dir=\${out_dir_Path}"
                echo "${CURRENT_MODULE}_ROOT_INSTALL_DIR=\${ROOT_EDF}/${CURRENT_MODULE_DIR}"
            } > $SFILE

            chmod a+x $SFILE

            {
                echo "# $(get-module-name $module)"
                echo "import os.path"
                echo "def init(context, root_dir):"
                echo "   ROOT_EDF=os.path.join(root_dir, r\"EDF\")"
                echo "   ${CURRENT_MODULE}_ROOT_INSTALL_DIR=os.path.join(ROOT_EDF, r\"${CURRENT_MODULE_DIR}\")"
            } > $PFILE

            # Call <module>-env hook which will be using the define-var
            # above.

            plugin-call-env-hooks $FORMODULE $MODREF env

            local MLIST=()
            local FMODULE=$FORMODULE

            if [[ $IS_AGGREGATE != false ]]; then
                MLIST=( $(plugin-call-variant-hooks \
                              $module modules \
                              $SCBI_PREFIX $SCBI_TARGET $variant) )
                FMODULE=$module
            else
                MLIST=( $module )
            fi

            for MOD in ${MLIST[*]}; do
                #  Handle possible ctest support

                local m_info=()
                get-module-ref m_info $MOD $FMODULE
                local m=${m_info[0]}
                local v=${m_info[1]}

                get-hook FCT $m $v ctest-dir

                if [[ -n $FCT ]]; then
                    echo "SUBDIRS(../../../../../$($FCT EDF/$module))" \
                         >> $SBINDIR/bin/salome/test/CTestTestfile.cmake
                fi
            done
        }

        #  Patch env_launch.sh
        #  to be able to call the extra.env.d/*.sh from env_launch.sh

        cat << EOF >> env_launch.sh
while read F; do
    source \$F
done < <(find \$out_dir_Path/extra.env.d/ -type f -name "[0-9]*.sh" | sort -V)
EOF

        #  The directory where the environment files are stored
        mkdir -p extra.env.d

        #  Override some possible values

        PFILE="extra.env.d/000_setup.py"

        local SVER=$(get-version)

        {
            echo "import os.path"
            echo ""
            echo "def init(context, root_dir):"
            echo '   context.setVariable(r"ROOT_SALOME_INSTALL", root_dir, overwrite=True)'
            echo '   context.setVariable(r"SALOME_VERSION", '\"$SVER\"', overwrite=True)'
            echo '   context.setVariable(r"PYTHON_VERSION", '\"$PYTHON_VERSION\"', overwrite=True)'
            echo '   context.setVariable(r"PYTHONIOENCODING", r"UTF_8", overwrite=True)'
            echo '   context.setVariable(r"SALOME_ON_DEMAND", r"HIDE", overwrite=True)'
        } > $PFILE

        SFILE="extra.env.d/000_setup.sh"

        {
            #  Dump definition of remove-from-string-sep from SCBI
            #  as needed to setup environment later.

            echo -n 'function '
            declare -f remove-from-string-sep
            echo

            echo "export ROOT_SALOME_INSTALL=\${out_dir_Path}"
            echo "export SALOME_VERSION=$SVER"
            echo "export PYTHON_VERSION=$PYTHON_VERSION"
            echo "export SALOME_ON_DEMAND=HIDE"
            echo "export PYTHONIOENCODING=UTF_8"
        } > $SFILE

        #  keep current PATH setting
        PATH_set=IS_SET

        for-all-modules-with-meta mod-callback s-salome
    )
}

function sync-delete-installed()
{
    local PLUGIN=$1
    local FROM=$2
    local TO=$3

    local BTO=${SCBI_EXTRA_NG_DEFS[$PLUGIN]}

    [[ -z $BTO ]] && return

    #  If module is on a separate directory, delete it

    if [[ -d $TO/$BTO ]]; then
        rm -fr $TO/$BTO
    elif [[ -d $TO/EXT ]]; then
        BTO=$TO/EXT

        [[ -d $FROM/$PLUGIN ]] &&
            (
                cd $FROM/$PLUGIN

                find . -type f | while read -r file; do
                    if [[ -f $BTO/$file ]]; then
                        rm -f $BTO/$file
                    else
                        #  This is a hack to check for a file in a directory
                        #  just above. Indeed some modules are installing the
                        #  binaries into bin/Linux_XXX/file, so we try to also
                        #  look into bin/file.

                        local F=$(basename $file)
                        local D=$(dirname $(dirname $file))
                        rm -f $BTO/$D/$F
                    fi
                done
            )
    fi
}

function copy-modules-salome()
{
    function mod-callback()
    {
        local FORMODULE=$1
        local MODREF=$2
        local LEVEL=$3
        local DEPENDS_KIND=$4
        local IS_EXT=$5
        local IS_META=$6
        local IS_AGGREGATED=$7

        local IS_AGGREGATE=false

        #  Nothing to copy for aggregated modules and build dependencies
        [[ $IS_AGGREGATED == true ]] || [[ $DEPENDS_KIND != default ]] &&
            return

        #  Nothing to copy for meta-modules, except if aggregate

        if [[ $IS_META == true ]]; then
            #  check if aggregate module

            is-meta-aggregate-module IS_AGGREGATE $MODREF

            [[ $? != 0 ]] && return
        fi

        local module_info=()
        get-module-ref module_info $MODREF $FORMODULE
        local module=${module_info[0]}
        local variant=${module_info[1]}

        #  Skip s-salome-tar as it is the root install and already
        #  handled. Also there is nothing to copy for externals.

        if [[ $IS_EXT == false ]] && [[ $module != "s-salome-tar" ]]; then
            local MODULE_PATH=$SCBI_BDIR/$module/$SCBI_TARGET-$variant/install

            if [[ -d $MODULE_PATH ]] && [[ ! -d EDF/$module ]]; then
                mkdir EDF/$module
                cp -r $MODULE_PATH/* EDF/$module
            fi

            #  We want to clean-up the MeshGems install provided in the
            #  binary archive.

            if [[ $module == "s-meshgems" ]] &&
                   [[ -n $SALOME_BINARY_DIR ]];
            then
                sync-delete-installed $module $PWD/EDF $PWD/$SALOME_BINARY_DIR
            fi
        fi

        #  Record source reference for QA

        local SREF=$SCBI_BDIR/$module/source-ref

        if [[ -f $SREF ]]; then
            cat $SREF | while read v1 v2 v3 v4 v5; do
                printf "%-25s %-11s %-20s %-9s %s\n" $v1 $v2 $v3 $v4 $v5 \
                       >> artifacts/source-refs.txt
            done
        fi
    }

    mkdir EDF

    rm -f artifacts/source-refs.txt

    for-all-modules-with-meta mod-callback s-salome
}

function s-salome-wrapup()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    local APPDIR=$TARGET-$VARIANT

    # Get s-salome-tar variant as used for s-salome-bin & s-salome-tar
    # env file creation and to copy the binaries.

    local module_info=()
    get-module-ref module_info s-salome-tar
    SALOME_TAR_VARIANT=${module_info[1]}

    local BINPAT=""

    if [[ $SCBI_IS_WINDOWS == yes ]]; then
        BINPAT=W64
    else
        BINPAT="BINARIES-*"
    fi

   (
        #  Clean-up previous installation if any

        mkdir -p $APPDIR
        cd $APPDIR

        #  Remove everything from previous build expect logs
        rm -fr x $(ls | grep -v logs)

        if [[ "$(is-enabled application)" = "yes" ]] \
               || [[ "$(is-enabled installer)" = "yes" ]];
        then
            dlog salome prepare the application directory

            has-variant $VARIANT ng &&
                {
                    #  Copy CEA's binaries

                    cp -r $SCBI_BDIR/s-salome-tar/$SCBI_TARGET-$SALOME_TAR_VARIANT/install/* .
                    #  Now that we have copied the binary archive, get
                    #  the binary dir
                    SALOME_BINARY_DIR=$(basename $(ls -1d $BINPAT))
                }

            #  Add some build artifacts for traceability

            mkdir -p artifacts
            cp logs/build-plan artifacts
            rm -fr logs

            date > artifacts/creation-time.txt
            scbi --version > artifacts/scbi_versions.txt

            [[ -n $CI_JOB_NAME ]] &&
                echo CI_JOB_NAME $CI_JOB_NAME >> artifacts/gitlab-ci.data
            [[ -n $CI_PIPELINE_ID ]] &&
                echo CI_PIPELINE_ID $CI_PIPELINE_ID  >> artifacts/gitlab-ci.data

            #  Copy EDF's modules into sub-directory EDF

            copy-modules-salome

            dlog salome setup application environment

            setup-env-salome $PREFIX $TARGET $VARIANT

            res=0

            # compute the final installer script name

            local module_info=()
            get-module-ref module_info s-salome
            local module=${module_info[0]}
            local variant=${module_info[1]}
            local kind=${module_info[2]}
            local ref=${module_info[3]}

            # install some support scripts & patch version

            cp $SCBI_PLUGINS/support/install-meshgems .
            cp $SCBI_PLUGINS/support/create-catalog .
            cp $SCBI_PLUGINS/support/icon.png .
            cp $SCBI_PLUGINS/support/salome_template.desktop .

            ! has-variant $VARIANT ng &&
                {
                    cp $SCBI_PLUGINS/support/env_launch.sh .
                    cp $SCBI_PLUGINS/support/salome .
                    cp EDF/s-salome-kernel/bin/salome/appliskel/.bashrc \
                       EDF/s-salome-kernel
                    chmod a+x salome env_launch.sh
                }

            sed -i "s/<salome_version>/${ref#*-}/g" create-catalog
            chmod a+x create-catalog

            chmod a+x install-meshgems

            # do we want to activate the logger

            if [[ $(is-enabled logger) ]]; then
                # add script to start the logger
                local WSERVER=$(scbi-store LOGGER_WEB_SERVER)
                sed -e "s/__SALOME_VERSION__/$ref/g" \
                    -e "s,__WEB_SERVER__,$WSERVER,g" \
                    $SCBI_PLUGINS/support/start-slogger.py \
                    > extra.env.d/999_start_s_logger.py
            fi

            # is the installer to be created?

            if [[ $(is-enabled installer) ]] || [[ $(is-enabled zip) ]]; then
                if [[ $(is-enabled zip) ]]; then
                    dlog salome generate zip archive, may take some time ...

                    # check that zip is installed
                    check-tool zip
                    if [[ $? != 0 ]]; then
                        dlog salome required tool zip missing
                        exit 1
                    fi
                else
                    dlog salome generate self installer, may take some time ...

                    # check that makeself is installed
                    check-tool makeself
                    if [[ $? != 0 ]]; then
                        dlog salome required tool makeself missing
                        exit 1
                    fi
                fi

                # create the .run auto-installer to be distributed

                host=$(hostname)
                local TMPLT=""

                if [[ $host =~ "crfront" ]] || [[ $host =~ "gafront" ]]; then
                    TMPLT=$SCBI_PLUGINS/support/install-setup-cluster
                else
                    TMPLT=$SCBI_PLUGINS/support/install-setup
                fi

                sed "s,__SALOMEVERSION__,$SALOME_PREREQUIS_VERSION,g" \
                    $TMPLT > setup

                cp $SCBI_PLUGINS/support/install-setup-common .

                chmod a+x setup

                cp $SCBI_PLUGINS/support/servers.pvsc .
                cp $SCBI_PLUGINS/support/salome_hpc_visu_servers.py .

                # Startup Windows script to fix Python path to get
                # access to PyQt needed by the logger start script.

                if [[ $SCBI_IS_WINDOWS == yes ]]; then
                    cp $SCBI_PLUGINS/support/run_mesa_salome.bat  .
                    cp $SCBI_PLUGINS/support/run_paraview.bat     .
                    cp $SCBI_PLUGINS/support/run_persalys.bat     .
                    cp $SCBI_PLUGINS/support/run_salome.bat       .
                    cp $SCBI_PLUGINS/support/run_salome_shell.bat .
                fi

                cd $SCBI_BDIR/s-salome

                local script_name=salome-$TARGET-$variant

                case $kind in
                    DEV)
                        script_name=$script_name-DEV
                        ;;
                    BRANCH|VERSION)
                        script_name=$script_name-$ref
                        ;;
                    *)
                        ;;
                esac

                # --sha256 in 2.4 only

                if [[ $(is-enabled xz) ]]; then
                    # -xz compress 40% more but is slow to compress
                    O_COMPRESS="--xz"
                else
                    O_COMPRESS="--bzip2"
                fi

                #  We do not fix path here as currently this is done in
                #  s-salome-tar for the binary release. For the current
                #  build on Debian >= 10 we use a native Python & HDF5
                #  so no patch is needed.

                if [[ $(is-enabled zip) ]]; then
                    rm -f $script_name.zip salome-$ref
                    if [[ $SCBI_IS_WINDOWS == yes ]]; then
                        ln -s $APPDIR salome-$ref
                        zip -9r $script_name.zip salome-$ref
                        rm -f salome-$ref
                    else
                        zip -9r $script_name.zip $APPDIR
                    fi
                else
                    makeself $O_COMPRESS --tar-quietly \
                             $APPDIR $script_name.run \
                             "SALOME Application" ./setup
                fi
                res=$?
                rm -rf application_tmp
            fi

            if [[ $res == 0 ]]; then
                true
            else
                false
            fi

        else
            true
        fi
    )
}
