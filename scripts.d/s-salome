
function s-salome-hydro-modules()
{

    echo s-libecw2
    echo s-mumps
    echo s-scalapack
    echo s-gotm
    echo s-aed2
}

function s-salome-cfd-modules()
{
    echo s-syrthes
    echo s-cfd-study

    echo s-libccmio
    echo s-coolprop
    echo s-code-syrthes
    echo s-saturne
    echo s-saturne-dbg
}

function s-salome-modules()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    echo s-salome-configuration

    echo s-salome-kernel
    echo s-salome-gui
    echo s-salome-plugins
    echo s-shaper
    echo s-shaperstudy
    echo s-geom
    echo s-smesh
    echo s-paravis
    echo s-fields
    echo s-yacs
    echo s-salome-adao
    echo s-ydefx
    echo s-salome-eficas
    echo s-salome-jobmanager
    echo s-homard
    echo s-atomic
    echo s-atomgen
    echo s-hexablock
    echo s-atomsolv
    echo s-calculator
    echo s-genericsolver
    echo s-hello
    echo s-pyhello
    echo s-light
    echo s-pylight
    echo s-salome-openturns

    echo s-adao
    echo s-adao-interface
    echo s-samples
    echo s-omniorb
    echo s-python-omniorb
    echo s-eficas-tools
    echo s-occt
    echo s-yacsgen
    echo s-medfichier
    echo s-medcoupling
    echo s-libbatch
    echo s-py2cpp
    echo s-planegcs
    echo s-ospray
    echo s-embree
    echo s-paraview
    echo s-gmsh
    echo s-paravisaddons-common
    echo s-persalys
    echo s-netgen
    echo s-openturns
    echo s-openturns-fftw
    echo s-openturns-mixmod
    echo s-openturns-morris
    echo s-openturns-pmml
    echo s-openturns-robopt
    echo s-openturns-subsetinverse
    echo s-openturns-svm
    echo s-openturns-wrapy
    echo s-openturns-pod
    echo s-openturns-fmi
    echo s-fmil
    echo s-pyfmi
    echo s-uranie
    echo s-root
    echo s-homard-tool
    echo s-zeromq
    echo s-python3-nlopt
    echo s-python3-xlutils
    echo s-rkcommon
    echo s-openvkl
    echo s-cgns
    echo s-ttk
    echo s-qt
    echo s-catalyst
    echo s-pyqt
    echo s-pyqt-sip
    echo s-sip
    echo s-topiivol
}

function s-salome-propagate-version()
{
    echo false
}

function s-salome-prefix()
{
    echo NONE
}

function build-salome-prerequisites()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    (
        FILE=salome_prerequisites.sh

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            # compute relative directory
            local REPLTO="\${${CURRENT_MODULE}_ROOT_INSTALL_DIR}"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_EXTERNAL\}}"

            local FCT=$(get-hook $CURRENT_MODULE_NAME $VARIANT salome-module)

            if [[ -n $FCT ]]; then
                REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_INSTALL\}}"
            fi

            {
                case "$VAR" in
                    C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*| \
                        *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                    ;;

                    SalomeAppConfig|SALOME_MODULES)
                    ;;

                    *)
                        VSET=${VAR}_set

                        if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                            echo export $VAR=${REL_DIR}${!VSET:+:\$${VAR}}
                        else
                            echo export $VAR=\"${REL_DIR}\"${!VSET:+:\$${VAR}}
                        fi

                        # mark $VAR as set to ensure that the previous value
                        # will be added on next call ${!VAR...} above.
                        export ${VAR}_set=IS_SET
                        ;;
                esac
            } >> $FILE
        }

        function env-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            CURRENT_MODULE_NAME=$module
            CURRENT_MODULE=${module//-/_}
            CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/build/install

            local FCTM=$(get-hook $module $VARIANT salome-module)

            {
                echo ""
                echo "# $module"

                echo -n "export ${CURRENT_MODULE}_ROOT_INSTALL_DIR="

                if [[ -n $FCTM ]]; then
                    echo "\${ROOT_INSTALL}"
                else
                    echo "\${ROOT_EXTERNAL}/${module}"
                fi
            } >> $FILE

            plugin-call-variant-hooks $module env \
                                      $CURRENT_MODULE_INSTALL $TARGET $variant
        }

        local SVER=$(get-version)

        {
            echo
            echo "export ROOT_INSTALL=\$(dirname \$(command -v \$BASH_SOURCE))"
            echo "export ROOT_EXTERNAL=\$ROOT_INSTALL/external"
            echo "export SALOME_VERSION=$SVER"
        } > $FILE

        # keep current PATH setting
        PATH_set=IS_SET

        for-all-modules-with-meta env-callback s-salome

	chmod u+x $FILE
    )
}

function build-salome-context()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    (
        FILE=salome_context.cfg

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            # compute relative directory
            local REPLTO="%(${CURRENT_MODULE}_ROOT_INSTALL_DIR)s"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/%(ROOT_EXTERNAL)s}"

            local FCT=$(get-hook $CURRENT_MODULE_NAME $VARIANT salome-module)

            if [[ -n $FCT ]]; then
                REL_DIR="${REL_TMP/$SCBI_BDIR/%(ROOT_INSTALL)s}"
            fi

            {
                case "$VAR" in
                    LD_LIBRARY_PATH|PYTHONPATH|PATH|QT_PLUGIN_PATH \
                        |PV_PLUGIN_PATH)
                        echo "ADD_TO_$VAR: ${REL_DIR}"
                        ;;

                    C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*\
                        |*INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                        ;;

                    SalomeAppConfig|SALOME_MODULES)
                        ;;

                    *)
                        if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                            echo $VAR=$REL_DIR
                        else
                            echo $VAR=\"$REL_DIR\"
                        fi
                        ;;
                esac
            } >> $FILE
        }

        function env-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            CURRENT_MODULE_NAME=$module
            CURRENT_MODULE=${module//-/_}
            CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/build/install

            local FCTM=$(get-hook $module $VARIANT salome-module)

            {
                echo ""
                echo "# $module"

                echo -n "${CURRENT_MODULE}_ROOT_INSTALL_DIR="

                if [[ -n $FCTM ]]; then
                    echo "%(ROOT_INSTALL)s"
                else
                    echo "%(ROOT_EXTERNAL)s/${module}"
                fi
            }  >> $FILE

            plugin-call-variant-hooks $module env \
                                      $CURRENT_MODULE_INSTALL $TARGET $variant
        }

        local SVER=$(get-version)

        {
            echo "[SALOME Configuration]"
            echo "ROOT_INSTALL=\${ROOT_SALOME_INSTALL}"
            echo "ROOT_EXTERNAL=%(ROOT_INSTALL)s/external"
            echo "SALOME_VERSION=$SVER"
            echo "LC_NUMERIC=C"
            echo "ADD_TO_SALOME_PLUGINS_PATH:\"%(ROOT_EXTERNAL)s/plugins\""
            echo "ADD_TO_PV_PLUGIN_PATH: \"%(ROOT_INSTALL)s/lib/paraview\""
            echo "ADD_TO_PATH: \"%(ROOT_INSTALL)s/bin/salome\""
        } > $FILE

        for-all-modules-with-meta env-callback s-salome
    )
}

function build-config-appli()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    FILE=config_appli.xml

    cat <<EOF > $FILE
<application>
   <prerequisites path='$PWD/salome_prerequisites.sh'/>
   <context path='$PWD/salome_context.cfg'/>
   <modules>
EOF

    function main-module-callback()
    {
        local FORMODULE=$1
        local MODREF=$2
        local LEVEL=$3
        local IS_BUILD_DEPENDS=$4
        local IS_EXT=$5
        local IS_META=$6

        local module_info=( $(get-module-ref $MODREF $FORMODULE) )
        local module=${module_info[0]}
        local variant=${module_info[1]}

        local SMOD=$(get-hook-value $module $variant salome-module)

        if [[ -n $SMOD ]]; then
            MODULE_PATH=$SCBI_BDIR/$module/build/install

            echo "      <module name='$SMOD'"           >> $FILE
            echo "              path='$MODULE_PATH'/>"  >> $FILE
        fi
    }

    function prerequisite-module-callback()
    {
        local FORMODULE=$1
        local MODREF=$2
        local LEVEL=$3
        local IS_BUILD_DEPENDS=$4
        local IS_EXT=$5
        local IS_META=$6

        local module_info=( $(get-module-ref $MODREF $FORMODULE) )
        local module=${module_info[0]}
        local variant=${module_info[1]}

        local SMOD=$(get-hook-value $module $variant salome-module)

        if [[ -z $SMOD ]]; then
            MODULE_PATH=$SCBI_BDIR/$module/build/install

            {
	        case "$module" in
	            *"samples")
		        echo "   <samples path=\"$MODULE_PATH\"/>"
		        ;;
	            *"medcoupling"*)
		        echo "   <extra_tests>"
		        echo "      <extra_test name='MEDCOUPLING'"
		        echo "             path=\"$MODULE_PATH/tests\"/>"
		        echo "   </extra_tests>"
		        ;;
	            *"paravisaddons-common"*)
		        echo "   <extra_tests>"
                        echo "      <extra_test name='paravisaddons-common'"
                        echo "             path=\"$MODULE_PATH/tests\"/>"
                        echo "   </extra_tests>"
                        ;;
	            *)
		        ;;
	        esac
            } >> $FILE
        fi
    }

    for-all-modules-with-meta main-module-callback s-salome

    echo "   </modules>"                            >> $FILE

    # Generate extra configuration for SAMPLES & MEDCOUPLING

    for-all-modules-with-meta prerequisite-module-callback s-salome

    echo "</application>"                           >> $FILE
}

function s-salome-wrapup()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    # Finaly we create here:
    #
    # - salome_prerequisites.sh
    # - salome_context.cfg
    # - config_appli.xml
    # - the application directory
    # - the self installer

    (
        function cp-module-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            # Nothing to do for meta modules
            [[ $IS_META == true ]] && return;

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            local SMOD=$(get-hook-value $module $variant salome-module)

            # Some module may not be present if they have been skiped
            # in build plan (:skip)
            local MODULE_PATH=$SCBI_BDIR/$module/build/install

            if [[ -n $SMOD ]]; then
                for dir in include salome_adm adm_local; do
                    if [[ -d $MODULE_PATH/$dir ]]; then
                        cp -lr $MODULE_PATH/$dir .
                    fi
                done
            else
                if [[ -d $MODULE_PATH ]]; then
                    cp -lr $MODULE_PATH external/$module
                fi
            fi
        }

        rm -fr application
        mkdir application
        cd application

        dlog salome create application context

        #  Add some build artifacts for traceability

        mkdir artifacts

        date > artifacts/creation-time.txt
        scbi --version > artifacts/scbi_versions.txt

        cp ../$TARGET-$VARIANT/.log/build-plan artifacts/

        [[ ! -z $CI_JOB_NAME ]] &&
            echo CI_JOB_NAME $CI_JOB_NAME >> artifacts/gitlab-ci.data
        [[ ! -z $CI_PIPELINE_ID ]] &&
            echo CI_PIPELINE_ID $CI_PIPELINE_ID  >> artifacts/gitlab-ci.data

        # generate salome_prerequisites.sh shell script
        build-salome-prerequisites $PREFIX $TARGET $VARIANT

        # generate salome_context.cfg script
        build-salome-context $PREFIX $TARGET $VARIANT

        # generate config_appli.xml
        build-config-appli $PREFIX $TARGET $VARIANT

        if [[ "$(is-enabled application)" = "yes" ]] \
               || [[ "$(is-enabled installer)" = "yes" ]];
        then
            dlog salome generate application
            # generate the application directory
            $SCBI_BDIR/s-salome-kernel/build/install/bin/salome/appli_gen.py

            if [[ $? != 0 ]]; then
                elog salome Error while running appli_gen
                exit 1
            fi

            # salome application root dir
            APP_DIR=$SCBI_BDIR/s-salome

            # replace all symlinks outside the APP_DIR by a copy of
            # the corresponding files/directories. This makes the
            # application directory self contained.

            dlog salome fix links to be relative to application directory

            cd $APP_DIR

            find . -type l | while read link; do
                value=$(realpath --relative-to=$APP_DIR $link)

                # if link to level above $APP_DIR, copy

                if [[ ${value:0:3} = "../" ]]; then
                    rm -f $link
                    cp -r $value ${link}
                fi
            done

            local APP=$SCBI_BDIR/s-salome/application
            cd $APP

            # copy VERSION file of KERNEL on salome application

            rm -rf ./bin/salome/VERSION &&
                cp $SCBI_BDIR/s-salome-kernel/build/install/bin/salome/VERSION \
                   ./bin/salome/

            # fix broken symlink of yacs tests data

            (
                cd ./bin/salome/test/YACS/yacsloader_swig/ &&
                    rm -rf samples &&
                    ln -s ../../../../../share/salome/yacssamples samples
            )

            (
                cd ./bin/salome/test/YACS/yacsloader/ &&
                    rm -rf samples &&
                    ln -s ../../../../../share/salome/yacssamples samples
            )

            # replace toplevel links to reference local scripts

            for file in envd getAppliPath.py kill_remote_containers.py \
                        runRemote.sh update_catalogs.py .bashrc .salome_run;
            do
                rm -f $file
                ln -s ./bin/salome/appliskel/$file $file
            done

            sed -i 's,SCRIPTS_DIR "../../../../,SCRIPTS_DIR "$ENV{KERNEL_ROOT_DIR}/,g' \
                ./bin/salome/test/GEOM/examples/CTestTestfile.cmake

            # patch bin/salome/test/CTestTestfile.cmake
            # add KERNEL first.

            sed -i 's/SUBDIRS(KERNEL)//;1iSUBDIRS(KERNEL)' \
                ./bin/salome/test/CTestTestfile.cmake

            # copy module dev support

            dlog salome "copy the modules"

            mkdir external

            for-all-modules-with-meta cp-module-callback s-salome

            # is the installer to be created?

            res=0

            # compute the final installer script name

            local module_info=( $(get-module-ref s-salome) )
            local module=${module_info[0]}
            local variant=${module_info[1]}
            local kind=${module_info[2]}
            local ref=${module_info[3]}

            if [[ $(is-enabled installer) ]]; then
                dlog salome generate self installer, may take some time ...

                # check that makeself is installed
                check-tool makeself
                if [[ $? != 0 ]]; then
                    dlog salome Required tool makeself missing
                    exit 1
                fi

                # create the .run auto-installer to be distributed

                sed "s,__SALOMEVERSION__,$SALOME_PREREQUIS_VERSION,g" \
                    $SCBI_PLUGINS/support/install-setup > $APP/setup
                cp $SCBI_PLUGINS/support/install-setup-common $APP/
                chmod a+x $APP/setup

                cp $SCBI_PLUGINS/support/salome_template.desktop $APP/
                cp $SCBI_PLUGINS/support/icon.png $APP/

                cp $SCBI_PLUGINS/support/servers.pvsc $APP/

                cp $SCBI_PLUGINS/support/salome_hpc_visu_servers.py $APP/
                chmod a+x $APP/salome_hpc_visu_servers.py

                cd $SCBI_BDIR/s-salome

                local script_name=salome-$TARGET-$variant

                case $kind in
                    DEV)
                        script_name=$script_name-DEV
                        ;;
                    BRANCH|VERSION)
                        script_name=$script_name-$ref
                        ;;
                    *)
                        ;;
                esac

                # --sha256 in 2.4 only

                if [[ $(is-enabled xz) ]]; then
                    # -xz compress 40% more but is slow to compress
                    O_COMPRESS="--xz"
                else
                    O_COMPRESS="--bzip2"
                fi

                makeself $O_COMPRESS --tar-quietly \
                         application $script_name.run \
                         "SALOME Application" ./setup
                res=$?
            fi

            # check for python3
            #
            if [[ -z "$(python --version 2>&1 | grep ' 3\.')" ]]; then
                dlog python2 is default, checking for python3
                if [[ -f /usr/bin/python3 ]]; then
                    dlog found python3 in /usr/bin/python3, setup links
                    (
                        cd $APP
                        rm -f ./bin/python ./bin/salome/python
                        ln -s /usr/bin/python3 ./bin/python
                        ln -s /usr/bin/python3 ./bin/salome/python
                    )
                else
                    dlog cannot found a python3 installation.
                    dlog SALOME will not work properly.
                fi
            fi

            if [[ $res == 0 ]]; then
                true
            else
                false
            fi

        else
            true
        fi
    )
}
