
function s-salome-hydro-modules()
{
    echo s-hydro
    echo s-hydrosolver

    echo s-libecw2
    echo s-mumps
    echo s-scalapack
    echo s-gotm
    echo s-aed2
    echo s-metis-hydro
    echo s-telemac
    echo s-geos
}

function s-salome-cfd-modules()
{
    echo s-syrthes
    echo s-cfd-study

    echo s-libccmio
    echo s-coolprop
    echo s-code-syrthes
    echo s-saturne
    echo s-saturne-dbg
}

function s-salome-carmel-modules()
{
    echo s-carmel-study
}

function s-salome-neptune-modules()
{
    echo s-neptune
    echo s-eos
}

function s-salome-modules()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    echo s-salome-configuration

    echo s-salome-kernel
    echo s-salome-gui
    echo s-salome-plugins
    echo s-shaper
    echo s-shaperstudy
    echo s-geom
    echo s-smesh
    echo s-paravis
    echo s-fields
    echo s-yacs
    echo s-salome-adao
    echo s-ydefx
    echo s-salome-eficas
    echo s-salome-jobmanager
    echo s-homard
    echo s-atomic
    echo s-atomgen
    echo s-hexablock
    echo s-atomsolv
    echo s-calculator
    echo s-genericsolver
    echo s-hello
    echo s-pyhello
    echo s-light
    echo s-pylight
    echo s-dsccode
    echo s-melidefx
    echo s-salome-openturns
    echo s-non-regression-tests
    echo s-clustertests

    echo s-adao
    echo s-adao-interface
    echo s-samples
    echo s-omniorb
    echo s-python-omniorb
    echo s-eficas-tools
    echo s-occt
    echo s-yacsgen
    echo s-medfichier
    echo s-medcoupling
    echo s-libbatch
    echo s-py2cpp
    echo s-meshgems
    echo s-planegcs
    echo s-ospray
    echo s-embree
    echo s-paraview
    echo s-gmsh
    echo s-paravisaddons-edf
    echo s-paravisaddons-common
    echo s-persalys
    echo s-netgen
    echo s-openturns
    echo s-openturns-fftw
    echo s-openturns-mixmod
    echo s-openturns-morris
    echo s-openturns-pmml
    echo s-openturns-robopt
    echo s-openturns-subsetinverse
    echo s-openturns-svm
    echo s-openturns-wrapy
    echo s-openturns-pod
    echo s-openturns-fmi
    echo s-fmil
    echo s-pyfmi
    echo s-uranie
    echo s-root
    echo s-homard-tool
    echo s-zeromq
    echo s-melissa
    echo s-python3-nlopt
    echo s-python3-xlutils
    echo s-rkcommon
    echo s-openvkl
    echo s-zcracks
    echo s-cgns
    echo s-ttk
    echo s-qt
    echo s-catalyst
    echo s-pyqt
    echo s-pyqt-sip
    echo s-sip
    echo s-topiivol
}

function s-salome-propagate-version()
{
    echo false
}

function s-salome-prefix()
{
    echo NONE
}

function build-salome-prerequisites()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    (
        FILE=salome_prerequisites.sh

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            # compute relative directory
            local REPLTO="\${${CURRENT_MODULE}_ROOT_INSTALL_DIR}"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_EXTERNAL\}}"

            local FCT=$(get-hook $CURRENT_MODULE_NAME $VARIANT salome-module)

            if [[ -n $FCT ]]; then
                REL_DIR="${REL_TMP/$SCBI_BDIR/\$\{ROOT_INSTALL\}}"
            fi

            case "$VAR" in
                C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*| \
                    *INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                ;;

                SalomeAppConfig|SALOME_MODULES)
                ;;

                *)
                    VSET=${VAR}_set

                    if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                        echo export $VAR=${REL_DIR}${!VSET:+:\$${VAR}} >> $FILE
                    else
                        echo export $VAR=\"${REL_DIR}\"${!VSET:+:\$${VAR}} >> $FILE
                    fi

                    # mark $VAR as set to ensure that the previous value
                    # will be added on next call ${!VAR...} above.
                    export ${VAR}_set=IS_SET
                    ;;
            esac
        }

        function env-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            local FCT=$(get-hook $module $variant env)

            if [[ -n $FCT ]]; then
                CURRENT_MODULE_NAME=$module
                CURRENT_MODULE=${module//-/_}
                CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/build/install

                echo ""          >> $FILE
                echo "# $module" >> $FILE

                echo -n "export ${CURRENT_MODULE}_ROOT_INSTALL_DIR=" >> $FILE

                local FCTM=$(get-hook $module $VARIANT salome-module)

                if [[ -n $FCTM ]]; then
                    echo "\${ROOT_INSTALL}"                          >> $FILE
                else
                    echo "\${ROOT_EXTERNAL}/${module}"               >> $FILE
                fi

                $FCT $CURRENT_MODULE_INSTALL $TARGET $variant
            fi
        }

        echo                                                            > $FILE
        echo "export ROOT_INSTALL=\$(dirname \$(command -v \$BASH_SOURCE))" >> $FILE
        echo "export ROOT_EXTERNAL=\$ROOT_INSTALL/external"            >> $FILE

        # keep current PATH setting
        PATH_set=IS_SET

        for-all-modules-with-meta env-callback s-salome

	chmod u+x $FILE
    )
}

function build-salome-context()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    (
        FILE=salome_context.cfg

        CURRENT_MODULE_NAME=
        CURRENT_MODULE=
        CURRENT_MODULE_INSTALL=

        function define-var()
        {
            local ACTION=$1
            local VAR=$2
            local VALUE=$3

            # compute relative directory
            local REPLTO="%(${CURRENT_MODULE}_ROOT_INSTALL_DIR)s"
            local REL_TMP="${VALUE/$CURRENT_MODULE_INSTALL/$REPLTO}"
            local REL_DIR="${REL_TMP/$SCBI_BDIR/%(ROOT_EXTERNAL)s}"

            local FCT=$(get-hook $CURRENT_MODULE_NAME $VARIANT salome-module)

            if [[ -n $FCT ]]; then
                REL_DIR="${REL_TMP/$SCBI_BDIR/%(ROOT_INSTALL)s}"
            fi

            case "$VAR" in
                LD_LIBRARY_PATH|PYTHONPATH|PATH|QT_PLUGIN_PATH|PV_PLUGIN_PATH)
                    echo "ADD_TO_$VAR: ${REL_DIR}" >> $FILE
                    ;;

                C_INCLUDE_PATH|CPLUS_INCLUDE_PATH|CMAKE_*\
                    |*INCLUDE_DIR|*INCLUDE_DIRS|LIBRARY_PATH)
                    ;;

                SalomeAppConfig|SALOME_MODULES)
                    ;;

                *)
                    if [[ "${REL_DIR}" == "${REL_DIR/ /_}" ]]; then
                        echo $VAR=$REL_DIR >> $FILE
                    else
                        echo $VAR=\"$REL_DIR\" >> $FILE
                    fi
                    ;;
            esac
        }

        function env-callback()
        {
            local FORMODULE=$1
            local MODREF=$2
            local LEVEL=$3
            local IS_BUILD_DEPENDS=$4
            local IS_EXT=$5
            local IS_META=$6

            local module_info=( $(get-module-ref $MODREF $FORMODULE) )
            local module=${module_info[0]}
            local variant=${module_info[1]}

            FCT=$(get-hook $module $variant env)

            if [[ ! -z $FCT ]]; then
                CURRENT_MODULE_NAME=$module
                CURRENT_MODULE=${module//-/_}
                CURRENT_MODULE_INSTALL=$SCBI_BDIR/$module/build/install

                echo ""          >> $FILE
                echo "# $module" >> $FILE

                echo -n "${CURRENT_MODULE}_ROOT_INSTALL_DIR=" >> $FILE

                local FCTM=$(get-hook $module $VARIANT salome-module)

                if [[ -n $FCTM ]]; then
                    echo "%(ROOT_INSTALL)s"                   >> $FILE
                else
                    echo "%(ROOT_EXTERNAL)s/${module}"        >> $FILE
                fi

                $FCT $CURRENT_MODULE_INSTALL $TARGET $variant
            fi
        }

        echo "[SALOME Configuration]"                                    > $FILE
        echo "ROOT_INSTALL=\${ROOT_SALOME_INSTALL}"                     >> $FILE
        echo "ROOT_EXTERNAL=%(ROOT_INSTALL)s/external"                  >> $FILE
        echo "LC_NUMERIC=C"                                             >> $FILE
        echo "ADD_TO_SALOME_PLUGINS_PATH:\"%(ROOT_EXTERNAL)s/plugins\"" >> $FILE
        echo "ADD_TO_PV_PLUGIN_PATH: \"%(ROOT_INSTALL)s/lib/paraview\"" >> $FILE
        echo "ADD_TO_PATH: \"%(ROOT_INSTALL)s/bin/salome\""             >> $FILE

        for-all-modules-with-meta env-callback s-salome
    )
}

function build-config-appli()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    FILE=config_appli.xml

    cat <<EOF > $FILE
<application>
   <prerequisites path='$PWD/salome_prerequisites.sh'/>
   <context path='$PWD/salome_context.cfg'/>
   <modules>
EOF

    function main-module-callback()
    {
        local FORMODULE=$1
        local MODREF=$2
        local LEVEL=$3
        local IS_BUILD_DEPENDS=$4
        local IS_EXT=$5
        local IS_META=$6

        local module_info=( $(get-module-ref $MODREF $FORMODULE) )
        local module=${module_info[0]}
        local variant=${module_info[1]}

        local SMOD=$(get-hook-value $module $variant salome-module)

        if [[ -n $SMOD ]]; then
            MODULE_PATH=$SCBI_BDIR/$module/build/install

            echo "      <module name='$SMOD'"           >> $FILE
            echo "              path='$MODULE_PATH'/>"  >> $FILE
        fi
    }

    function prerequisite-module-callback()
    {
        local FORMODULE=$1
        local MODREF=$2
        local LEVEL=$3
        local IS_BUILD_DEPENDS=$4
        local IS_EXT=$5
        local IS_META=$6

        local module_info=( $(get-module-ref $MODREF $FORMODULE) )
        local module=${module_info[0]}
        local variant=${module_info[1]}

        local SMOD=$(get-hook-value $module $variant salome-module)

        if [[ -z $SMOD ]]; then
            MODULE_PATH=$SCBI_BDIR/$module/build/install

	    case "$module" in
	        *"samples")
		    echo "   <samples path=\"$MODULE_PATH\"/>"           >> $FILE
		    ;;
	        *"medcoupling"*)
		    echo "   <extra_tests>"                              >> $FILE
		    echo "      <extra_test name='MEDCOUPLING'"          >> $FILE
		    echo "             path=\"$MODULE_PATH/tests\"/>"    >> $FILE
		    echo "   </extra_tests>"                             >> $FILE
		    ;;
	        *"paravisaddons-common"*)
		    echo "   <extra_tests>"                              >> $FILE
                    echo "      <extra_test name='paravisaddons-common'" >> $FILE
                    echo "             path=\"$MODULE_PATH/tests\"/>"    >> $FILE
                    echo "   </extra_tests>"                             >> $FILE
                    ;;
	        *)
		    ;;
	    esac
        fi
    }

    for-all-modules-with-meta main-module-callback s-salome

    echo "   </modules>"                            >> $FILE

    # Generate extra configuration for SAMPLES & MEDCOUPLING

    for-all-modules-with-meta prerequisite-module-callback s-salome

    echo "</application>"                           >> $FILE
}

function s-salome-wrapup()
{
    local PREFIX=$1
    local TARGET=$2
    local VARIANT=$3

    # Finaly we create here:
    #
    # - salome_prerequisites.sh
    # - salome_context.cfg
    # - config_appli.xml
    # - the application directory
    # - the self installer

    (
        rm -fr application
        mkdir application
        cd application

        dlog salome create application context

        #  Add some build artifacts for traceability

        mkdir artifacts

        cp $SCBI_PLUGINS/.scbi_core_version.txt \
           artifacts/scbi_core_version.txt
        cp $SCBI_PLUGINS/.scbi_salome_version.txt \
           artifacts/scbi_salome_version.txt

        [[ ! -z $CI_JOB_NAME ]] &&
            echo CI_JOB_NAME $CI_JOB_NAME >> artifacts/gitlab-ci.data
        [[ ! -z $CI_PIPELINE_ID ]] &&
            echo CI_PIPELINE_ID $CI_PIPELINE_ID  >> artifacts/gitlab-ci.data

        # generate salome_prerequisites.sh shell script
        build-salome-prerequisites $PREFIX $TARGET $VARIANT

        # generate salome_context.cfg script
        build-salome-context $PREFIX $TARGET $VARIANT

        # generate config_appli.xml
        build-config-appli $PREFIX $TARGET $VARIANT

        if [[ "$(is-enabled application)" = "yes" ]] \
               || [[ "$(is-enabled installer)" = "yes" ]];
        then
            dlog salome generate application
            # generate the application directory
            $SCBI_BDIR/s-salome-kernel/build/install/bin/salome/appli_gen.py

            if [[ $? != 0 ]]; then
                elog salome Error while running appli_gen
                exit 1
            fi

            # salome application root dir
            APP_DIR=$SCBI_BDIR/s-salome

            # replace all symlinks outside the APP_DIR by a copy of
            # the corresponding files/directories. This makes the
            # application directory self contained.

            dlog salome fix links to be relative to application directory

            cd $APP_DIR

            find . -type l | while read link; do
                value=$(realpath --relative-to=$APP_DIR $link)

                # if link to level above $APP_DIR, copy

                if [[ ${value:0:3} = "../" ]]; then
                    rm -f $link
                    cp -r $value ${link}
                fi
            done

            local APP=$SCBI_BDIR/s-salome/application
            cd $APP

            # copy VERSION file of KERNEL on salome application

            rm -rf ./bin/salome/VERSION &&
                cp $SCBI_BDIR/s-salome-kernel/build/install/bin/salome/VERSION \
                   ./bin/salome/

            # fix broken symlink of yacs tests data

            (
                cd ./bin/salome/test/YACS/yacsloader_swig/ &&
                    rm -rf samples &&
                    ln -s ../../../../../share/salome/yacssamples samples
            )

            (
                cd ./bin/salome/test/YACS/yacsloader/ &&
                    rm -rf samples &&
                    ln -s ../../../../../share/salome/yacssamples samples
            )

            # generate the scbi_versions.txt for tracability

            scbi --version > .scbi_versions.txt

            # replace toplevel links to reference local scripts

            for file in envd getAppliPath.py kill_remote_containers.py \
                        runRemote.sh update_catalogs.py .bashrc .salome_run;
            do
                rm -f $file
                ln -s ./bin/salome/appliskel/$file $file
            done

            sed -i 's,SCRIPTS_DIR "../../../../,SCRIPTS_DIR "$ENV{KERNEL_ROOT_DIR}/,g' \
                ./bin/salome/test/GEOM/examples/CTestTestfile.cmake

            # patch bin/salome/test/CTestTestfile.cmake
            # add KERNEL first.

            sed -i 's/SUBDIRS(KERNEL)//;1iSUBDIRS(KERNEL)' \
                ./bin/salome/test/CTestTestfile.cmake

            # copy module dev support

            dlog salome "copy the modules' dev support files"

            local MODS=$(s-salome-main-modules $PREFIX $TARGET $VARIANT)

            for module in $(for-final-modules $MODS); do
                MODULE_PATH=$SCBI_BDIR/$module/build/install

                for dir in include salome_adm adm_local; do
                    if [[ -d $MODULE_PATH/$dir ]]; then
                        cp -r $MODULE_PATH/$dir .
                    fi
                done
            done

            # copy all prerequisites

            dlog salome copy the pre-requisites

            mkdir external

            local MODS=$(s-salome-prerequisite-modules $PREFIX $TARGET $VARIANT)

            for p in $MODS; do
                # Some module may not be present if they have been skiped
                # in build plan (:skip)
                if [[ -d $SCBI_BDIR/$p/build/install ]]; then
                    cp -r $SCBI_BDIR/$p/build/install external/$p
                fi
            done

            # is the installer to be created?

            res=0

            # compute the final installer script name

            local module_info=( $(get-module-ref s-salome) )
            local module=${module_info[0]}
            local variant=${module_info[1]}
            local kind=${module_info[2]}
            local ref=${module_info[3]}

            if [[ $(is-enabled installer) ]]; then
                dlog salome generate self installer, may take some time ...

                # check that makeself is installed
                check-tool makeself
                if [[ $? != 0 ]]; then
                    dlog salome Required tool makeself missing
                    exit 1
                fi

                # create the .run auto-installer to be distributed

                cp $SCBI_PLUGINS/support/install-setup $APP/setup
                chmod a+x $APP/setup

                cp $SCBI_PLUGINS/support/servers.pvsc $APP/

                cp $SCBI_PLUGINS/support/salome_hpc_visu_servers.py $APP/
                chmod a+x $APP/salome_hpc_visu_servers.py

                cd $SCBI_BDIR/s-salome

                local script_name=salome-$TARGET-$variant

                case $kind in
                    DEV)
                        script_name=$script_name-DEV
                        ;;
                    BRANCH|VERSION)
                        script_name=$script_name-$ref
                        ;;
                    *)
                        ;;
                esac

                # --sha256 in 2.4 only

                if [[ $(is-enabled xz) ]]; then
                    # -xz compress 40% more but is slow to compress
                    O_COMPRESS="--xz"
                else
                    O_COMPRESS="--bzip2"
                fi

                makeself $O_COMPRESS --tar-quietly \
                         application $script_name.run \
                         "SALOME Application" ./setup
                res=$?
            fi

            # check for python3
            #
            if [[ -z "$(python --version 2>&1 | grep ' 3\.')" ]]; then
                dlog python2 is default, checking for python3
                if [[ -f /usr/bin/python3 ]]; then
                    dlog found python3 in /usr/bin/python3, setup links
                    (
                        cd $APP
                        rm -f ./bin/python ./bin/salome/python
                        ln -s /usr/bin/python3 ./bin/python
                        ln -s /usr/bin/python3 ./bin/salome/python
                    )
                else
                    dlog cannot found a python3 installation.
                    dlog SALOME will not work properly.
                fi
            fi

            if [[ $res == 0 ]]; then
                true
            else
                false
            fi

        else
            true
        fi
    )
}
